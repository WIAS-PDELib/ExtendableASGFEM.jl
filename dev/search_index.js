var documenterSearchIndex = {"docs":
[{"location":"modelproblems/#Model-Problems","page":"Model Problems","title":"Model Problems","text":"","category":"section"},{"location":"modelproblems/","page":"Model Problems","title":"Model Problems","text":"The following model problems are available and are dispatched via the following types.","category":"page"},{"location":"modelproblems/#ExtendableASGFEM.PoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.PoissonProblemPrimal","text":"abstract type PoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with linear stochastic coefficient a that seeks u such that\n\n-mathrmdiv(a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemPrimal","text":"abstract type LogTransformedPoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with exponential stochastic coefficient e^a that seeks u such that\n\n-mathrmdiv(e^a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\nThe stochastic Galerkin FEM solves the equivalent transformed problem\n\n-mathrmdiv(nabla u(yx)) - nabla a(yx) cdot nabla u(yx) = e^-a(yx) f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemDual","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemDual","text":"abstract type LogTransformedPoissonProblemDual <: ExtendableASGFEM.AbstractModelProblem\n\nDual log-transformed formulation of the Poisson problem with exponential stochastic coefficient (WIP).\n\n\n\n\n\n","category":"type"},{"location":"plots/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The following special plot functions are available and basically delegate to the plotting routines from ExtendableFEM/GridVisualize.","category":"page"},{"location":"plots/#ExtendableASGFEM.plot_basis-Union{Tuple{ONBasis{T, OBT, npoly, nquad}}, Tuple{nquad}, Tuple{npoly}, Tuple{OBT}, Tuple{T}} where {T, OBT, npoly, nquad}","page":"Plotting","title":"ExtendableASGFEM.plot_basis","text":"plot_basis(\n    ONB::ONBasis{T, OBT, npoly, nquad};\n    Plotter,\n    resolution,\n    kwargs...\n)\n\n\nplots the basis functions of the ONBasis ONB via GridVisualize. The Plotter argument determines the backend (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"plots/#ExtendableASGFEM.plot_modes-Tuple{SGFEVector}","page":"Plotting","title":"ExtendableASGFEM.plot_modes","text":"plot_modes(\n    sol::SGFEVector;\n    unknown,\n    Plotter,\n    nmodes,\n    ncols,\n    width,\n    sort\n) -> GridVisualize.GridVisualizer\n\n\nPlot scalar plots of the stochastic modes of an SGFEVector solution using ExtendableFEM.plots.GridVisualize.\n\nArguments\n\nsol::SGFEVector: The stochastic Galerkin finite element solution vector whose modes are to be visualized.\nunknown: (Optional, default: 1) Index of the unknown to plot (for multi-unknown systems).\nPlotter: (Optional) Plotting backend to use (e.g., GLMakie, CairoMakie, PyPlot, Plots).\nnmodes: (Optional) Number of stochastic modes to plot (default: all modes in the tensorized basis).\nncols: (Optional, default: 3) Number of columns in the plot grid.\nwidth: (Optional) Total width of the plot grid in pixels (default: 400 * ncols).\nsort: (Optional, default: false) If true, modes are sorted by their L2 norm (largest first).\n\nExample\n\nplot_modes(sol; Plotter=GLMakie, ncols=4, sort=true)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"Solving a problem requires both spatial and stochastic discretization. These are combined into a specialized vector structure, which is then passed to a solver function that executes an iterative algorithm tailored to each model problem.","category":"page"},{"location":"solvers/#SGFEVector","page":"Solver","title":"SGFEVector","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"The spatial discretization is defined by a single finite element space from ExtendableFEM.jl, while the stochastic discretization uses a tensorized basis for the parameter space of the stochastic coefficient. Both components must be set up in advance.","category":"page"},{"location":"solvers/","page":"Solver","title":"Solver","text":"note: Note\nCurrently, it is not possible to use different finite element spaces for different multi-indices. This feature may be added in the future.","category":"page"},{"location":"solvers/#ExtendableASGFEM.SGFEVector","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"struct SGFEVector{T, Tv, Ti, ONBType<:ONBasis, MIType}\n\nA structure that extends ExtendableFEMBase.FEVector to include information about the stochastic discretization, specifically the associated TensorizedBasis.\n\nFields\n\nFES_space: Array of finite element spaces for all stochastic modes.\nTB: The tensorized basis used for the stochastic discretization.\nactive_modes: Indices of the active stochastic modes (with respect to TB.multi_indices).\nlength4modes: Offsets for each mode in the global vector.\nFEVectorBlocks: Vector block mask for each multi-index (stochastic mode).\nentries: The full coefficient vector containing all degrees of freedom.\nlast_sample: The last sample used for evaluation (for efficient repeated evaluation).\nFEV: An FEVector used for evaluating the SGFEVector at a given sample.\n\nThis structure enables efficient storage, evaluation, and manipulation of solutions in stochastic Galerkin finite element methods.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ExtendableASGFEM.SGFEVector-Union{Tuple{MIType}, Tuple{ONBType}, Tuple{Ti}, Tuple{Tv}, Tuple{Vector{<:ExtendableFEMBase.FESpace{Tv, Ti}}, TensorizedBasis{Tv, ONBType, MIType}}} where {Tv, Ti, ONBType, MIType}","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"SGFEVector(\n    FES::Array{<:ExtendableFEMBase.FESpace{Tv, Ti}, 1},\n    TB::TensorizedBasis{Tv, ONBType, MIType};\n    active_modes,\n    T,\n    unames\n) -> SGFEVector\n\n\nConstructs an SGFEVector for the given spatial finite element spaces FES and the tensorized basis TB representing the stochastic discretization.\n\nArguments\n\nFES: Array of finite element spaces (one for each unknown).\nTB: The tensorized basis for the stochastic discretization.\nactive_modes: Indices of the active stochastic modes to include (default: all modes in TB).\nT: The floating-point type for the coefficient vector (default: Tv).\nunames: Names or identifiers for the unknowns (default: 1:length(FES)).\n\nReturns\n\nAn SGFEVector object that stores the spatial and stochastic discretization, the coefficient vector, and all necessary metadata for efficient evaluation and manipulation in stochastic Galerkin FEM.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    u::Int64,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the FEVectorBlock for the i-th stochastic mode of the u-th unknown\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the i-th stochastic mode\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.length-Tuple{SGFEVector}","page":"Solver","title":"Base.length","text":"length(SGFEV::SGFEVector) -> Int64\n\n\nreturns the length of the full vector, i.e., the total number of degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.show-Tuple{IO, SGFEVector}","page":"Solver","title":"Base.show","text":"show(io::IO, SGFEV::SGFEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.size-Tuple{SGFEVector}","page":"Solver","title":"Base.size","text":"size(SGFEV::SGFEVector)\n\n\nreturns a tuple with the number of active stochastic modes and the number of spatial degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.fetypes-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.fetypes","text":"fetypes(SGFEV::SGFEVector) -> Vector\n\n\nreturns the finite element types of the (spatial) FE spaces\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.num_multiindices-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(SGFEV::SGFEVector) -> Int64\n\n\nreturns the number of active modes (that are used from the stored tensorized basis)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.set_sample!-Tuple{SGFEVector, AbstractVector}","page":"Solver","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(SGFEV::SGFEVector, S::AbstractVector)\n\n\nEvaluates the SGFEVector at the given sample S and stores the result in SGFEV.FEV.\n\nArguments\n\nSGFEV: The stochastic Galerkin finite element vector to evaluate.\nS: A vector representing the sample (values for the stochastic variables).\n\nDetails\n\nThe sample S is stored in SGFEV.last_sample (truncated or padded as needed).\nThe tensorized basis is evaluated at S, and the resulting coefficients are used to assemble the spatial solution in SGFEV.FEV.\nThis enables efficient evaluation of the SGFEM solution at arbitrary points in the stochastic parameter space.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solve-Function","page":"Solver","title":"Solve Function","text":"","category":"section"},{"location":"solvers/#ExtendableASGFEM.solve!-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Solver","title":"ExtendableASGFEM.solve!","text":"solve!(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    rhs,\n    use_iterative_solver,\n    bonus_quadorder_f,\n    bonus_quadorder_a,\n    kwargs...\n)\n\n\nSolves the specified model problem using the provided stochastic coefficient C and right-hand side rhs, writing the solution into sol.\n\nThe sol vector communicates both the spatial and stochastic discretization, as well as any initial data required for the iterative solver.\n\nIf use_iterative_solver (default: true) is set, an iterative solver is used. Otherwise, the full system matrix is assembled and solved directly (note: this is very slow for large systems).\nThe parameters bonus_quadorder_f (default: 0) and bonus_quadorder_a (default: 2) allow you to increase the quadrature order for terms involving the right-hand side or the stochastic coefficient, respectively.\nAdditional keyword arguments can be passed via kwargs.\n\nIf no solver is implemented for the given model problem, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#TensorizedBasis","page":"TensorizedBasis","title":"TensorizedBasis","text":"","category":"section"},{"location":"tonbasis/","page":"TensorizedBasis","title":"TensorizedBasis","text":"Each multi-index mu = mu_1 mu_2 ldots mu_M defines a tensorized basis function for the parameter space of the form H_mu = prod_k=1^M H_k, where each H_k is an orthogonal polynomial.","category":"page"},{"location":"tonbasis/","page":"TensorizedBasis","title":"TensorizedBasis","text":"The TensorizedBasis object collects all information required to evaluate these basis functions, including the set of multi-indices and the triple products of the form (y_m H_mu H_lambda) for each m and mu lambda in the set of multi-indices, stored as a sparse matrix. While analytic formulas exist to compute these triple products using recurrence coefficients, storing them can significantly speed up evaluations.","category":"page"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"TensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder;\n    ...\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\nTensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder,\n    maxquadorder;\n    T,\n    multi_indices\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\n\nconstructor for a tensorized basis for the given OrthogonalPolynomialType. If no multi-indices are provided it automatically generates all multi-indices up to support length M and polynomial order maxorder.\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis-2","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"struct TensorizedBasis{T<:Real, ONBType<:ONBasis, MIType}\n\nA structure representing a tensorized orthogonal polynomial basis for stochastic Galerkin methods, associated with a given set of multi-indices.\n\nFields\n\nONB::ONBType: The underlying univariate orthogonal basis (e.g., Hermite, Legendre).\nvals::Vector{Vector{T}}: Cached evaluations of the univariate basis functions at the most recent sample(s).\nnmodes::Int: Number of multi-indices (i.e., the number of stochastic modes).\nG::ExtendableSparseMatrix{T, Int64}: Coupling matrix encoding triple products or recurrence relations between basis functions.\nmulti_indices::MIType: Collection of multi-indices (typically an array of integer arrays), each representing a multi-dimensional polynomial degree.\n\nDescription\n\nThe TensorizedBasis type encapsulates all information required to evaluate and manipulate a tensor-product polynomial basis in multiple stochastic dimensions. It supports efficient evaluation, storage of basis values, and access to coupling coefficients for use in stochastic Galerkin finite element methods (SGFEM).\n\nExample\n\n# Construct a tensorized Hermite basis with 3 variables and total degree 2\nTB = TensorizedBasis(HermitePolynomials, 3, 2, 2)\n\n# Evaluate all basis functions at a sample point\nset_sample!(TB, [0.1, -0.2, 0.3])\n\n# Get the value of the 5th basis function at the current sample\nval = evaluate(TB, 5)\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#Base.show-Tuple{IO, TensorizedBasis}","page":"TensorizedBasis","title":"Base.show","text":"show(io::IO, TB::TensorizedBasis)\n\n\nshows information on the tensorized basis.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.distribution-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.distribution","text":"distribution(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns distribution associated to the orthogonal basis\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(TB::TensorizedBasis{T}, j) -> Any\n\n\nevaluates the basis function for the j-th multi-index at the sample that was set with set_sample.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_coupling_coefficient-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any, Any, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.get_coupling_coefficient","text":"get_coupling_coefficient(\n    TB::TensorizedBasis{T},\n    m,\n    j,\n    k\n) -> Any\n\n\nreturns the triple products between y_m and H_j and H_k for two multi-indices j and k.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_multiindex-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.get_multiindex","text":"get_multiindex(TB::TensorizedBasis, j) -> Any\n\n\nreturns the j-th multi-index.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.maxlength_multiindices-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.maxlength_multiindices","text":"maxlength_multiindices(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns the maximal length of the stored multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.num_multiindices-Tuple{TensorizedBasis}","page":"TensorizedBasis","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(TB::TensorizedBasis) -> Int64\n\n\nreturns the number of multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.sample_distribution-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.sample_distribution","text":"sample_distribution(\n    TB::TensorizedBasis,\n    nsamples;\n    M,\n    Mweights\n) -> Tuple{Matrix{Float64}, Any}\n\n\nGenerate samples and weights for the distribution of the ON basis that the tensorized basis is based upon (that can be used for a Monte-Carlo estimator).\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.set_sample!-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(\n    TB::TensorizedBasis,\n    x;\n    normalize\n) -> Array{Vector{T}, 1} where T<:Real\n\n\nevaluates all basis functions at sample vector x; call this before using evaluate!\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#Stochastic-Coefficients","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"Stochastic coefficients play a central role in uncertainty quantification and stochastic finite element methods. In this package, coefficients are represented using a Karhunen-Loève expansion (KLE), which allows for the efficient representation of random fields with prescribed covariance structure.","category":"page"},{"location":"coefficients/#Overview","page":"Stochastic Coefficients","title":"Overview","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"The Karhunen-Loève expansion expresses a stochastic process as a series of orthogonal functions weighted by uncorrelated random variables:","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"$","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"a(x, \\omega) = a_0(x) + \\sum_{n=1}^N \\sqrt{\\lambda_n} \\phi_n(x) \\xi_n(\\omega)","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"$","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"where a_0(x) is the mean, lambda_n and phi_n(x) are the eigenvalues and eigenfunctions of the covariance operator, and xi_n are independent standard normal random variables.","category":"page"},{"location":"coefficients/#API","page":"Stochastic Coefficients","title":"API","text":"","category":"section"},{"location":"coefficients/#ExtendableASGFEM.AbstractStochasticCoefficient","page":"Stochastic Coefficients","title":"ExtendableASGFEM.AbstractStochasticCoefficient","text":"abstract type AbstractStochasticCoefficient{T}\n\nA stochastic coefficient is assumed to have the Karhunen-Loeve expansion form\n\na(yx) = a_0(x) + sum_m=1^infty y_m a_m(x) with (centered independent) random variables y_m and basis functions a_m(x) that need to be specified (together with their gradients) and expectation value a_0 (in general they steam from a spectral analysis of the covariance operator of a).\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.expa_PCE_mop-Union{Tuple{ONBType}, Tuple{T}, Tuple{TensorizedBasis{T, ONBType}, AbstractStochasticCoefficient{T}}} where {T, ONBType}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.expa_PCE_mop","text":"expa_PCE_mop(\n    TB::TensorizedBasis{T, ONBType},\n    SC::AbstractStochasticCoefficient{T};\n    N_truncate,\n    factor\n) -> Tuple{ExtendableASGFEM.var\"#closure#53\"{_A, TensorizedBasis{T, ONBType, MIType}, ExtendableASGFEM.var\"#lambda_mu#52\"{T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, Int64} where {_A, T, ONBType, MIType, T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, ExtendableASGFEM.var\"#lambda_mu#52\"{_A, Int64, Int64, <:AbstractStochasticCoefficient{T}} where {_A, T}}\n\n\nprepares two functions\n\nlambda_mu!(result, input, qpinfo)\nexpa!(result, input, qpinfo)\n\nthat calculate λ_μ, which are orthogonal decomposition coefficient functions of exp(a) ≈ ∑ λ_μ H_μ w.r.t. to the multi-indices μ and their associated orthogonal basis functions H_μ in TB, as well as (an approximation based on this decomposition of) exp(a).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_a!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_a!","text":"get_a!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#37\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\na!(result, x, y)\n\nthat evaluates the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_am_x-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_am_x","text":"get_am_x(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#46\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_am_x!(result, input, qpinfo)\n\nthat evaluates a_m(qpinfo.x) input (used to define ExtendableFEM operator kernels).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_expa!-Tuple{AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_expa!","text":"get_expa!(\n    SC::AbstractStochasticCoefficient;\n    factor\n) -> ExtendableASGFEM.var\"#closure#41\"{Int64, ExtendableASGFEM.var\"#closure#37\"{Int64, var\"#s182\", _A}} where {T, var\"#s182\"<:AbstractStochasticCoefficient{T}, _A}\n\n\nprepares a function of interface\n\nget_expa!(result, x, y)\n\nthat evaluates the exponential of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada!","text":"get_grada!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#39\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\nget_grada!(result, x, y)\n\nthat evaluates the spatial gradient of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of same length as x).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada_x_sigma-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}, Any}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada_x_sigma","text":"get_grada_x_sigma(\n    dim,\n    SC::AbstractStochasticCoefficient{T},\n    y\n) -> ExtendableASGFEM.var\"#closure#48\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_grada_x_sigma!(result, input, qpinfo)\n\nthat evaluates ∇a(qpinfo.x) ⋅ σ(qpinfo.x) (used to define ExtendableFEM operator kernels and σ is expected to be some vector-valued quantity of same length).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_gradam_x_u-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_gradam_x_u","text":"get_gradam_x_u(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#45\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_gradam_x_u!(result, input, qpinfo)\n\nthat evaluates ∇a_m(qpinfo.x) u(qpinfo.x) (used to define ExtendableFEM operator kernels and input is expected to be some scalar quantity).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.plot_am-Tuple{ExtendableGrids.ExtendableGrid, Any, AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.plot_am","text":"plot_am(\n    xgrid::ExtendableGrids.ExtendableGrid,\n    m,\n    SC::AbstractStochasticCoefficient;\n    Plotter,\n    kwargs...\n)\n\n\nreturns a scalarplot of the m-th coefficient functiona a_m interpolated on the given grid. The Plotter backend can be changed with the Plotter argument (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"StochasticCoefficientCosinus","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"An example of a particular KLE with cosinus type basis function is given by the following subtype.","category":"page"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"struct StochasticCoefficientCosinus{T} <: AbstractStochasticCoefficient{T}\n\nExpansion of the form\n\na(x,y) = a_0(x) + ∑_m y_m a_m(x)\n\nwhere the a_m are of cosinus type.\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus-Tuple{}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"StochasticCoefficientCosinus(\n;\n    T,\n    τ,\n    start,\n    decay,\n    mean,\n    maxm\n) -> StochasticCoefficientCosinus{Float64}\n\n\nconstructor for StochasticCoefficientCosinus of type T (default = Float64), where decay (default = 2) steers the decay of the coefficient basis functions (the larger the faster), mean (default = 0) is the mean value of the coefficient, maxm (default = 100) is the maximal number of stochastic random variables, and τ (default = 1) is a uniform scaling factors\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ONBasis","page":"ONBasis","title":"ONBasis","text":"","category":"section"},{"location":"onbasis/","page":"ONBasis","title":"ONBasis","text":"An ONBasis (orthonormal basis) encapsulates information about the orthogonal polynomials associated with a given probability distribution. This includes norms, quadrature rules, and cached evaluations at quadrature points. The ONBasis serves as a fundamental building block for constructing the tensorized basis linked to the multi-indices in the stochastic discretization.","category":"page"},{"location":"onbasis/#ExtendableASGFEM.ONBasis","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"ONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder;\n    ...\n) -> ONBasis{Float64}\nONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder,\n    maxquadorder;\n    T\n) -> ONBasis{Float64}\n\n\nConstructs an ONBasis for the given orthogonal polynomial type and associated weight function, up to the specified maximum polynomial order.\n\nArguments\n\nOBT: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nmaxorder: The highest polynomial degree to include in the basis.\nmaxquadorder: The quadrature order to use for integration (default: 2 * maxorder).\nT: The floating-point type for computations (default: Float64).\n\nReturns\n\nAn ONBasis object containing:\n\nThe norms of all basis functions.\nA workspace for storing evaluations.\nThe quadrature rule (points and weights).\nPrecomputed values of all basis functions at the quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.ONBasis-2","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"struct ONBasis{T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\nA structure that stores all relevant information for an orthonormal polynomial basis (ONBasis), including:\n\nThe norms of all basis functions.\nThe quadrature rule (points and weights) used for integration.\nPrecomputed values of all basis functions at the quadrature points.\nA workspace for storing the result of the last evaluation.\n\nThis structure enables efficient evaluation, integration, and manipulation of orthogonal polynomial bases for stochastic Galerkin methods and related applications.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.OrthogonalPolynomialType-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.OrthogonalPolynomialType","text":"OrthogonalPolynomialType(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the OrthogonalPolynomialType\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.distribution-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.distribution","text":"distribution(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the distribution associated to the orthogonal polynomials\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.evaluate-Union{Tuple{maxorder}, Tuple{OBT}, Tuple{T}, Tuple{ONBasis{T, OBT, maxorder}, Any}} where {T, OBT, maxorder}","page":"ONBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    ONB::ONBasis{T, OBT, maxorder},\n    x;\n    normalize\n) -> Vector\n\n\nEvaluates all basis polynomials at point x\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.integral-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.integral","text":"integral(ONB::ONBasis, j; normalize) -> Any\n\n\nEvaluates the integral of a single basis function.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.norm4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.norm4poly","text":"norm4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the norm of the p-th polynomial\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qp-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qp","text":"qp(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qw-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qw","text":"qw(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature weights\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.scalar_product-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.scalar_product","text":"scalar_product(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the scalar product of two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product-Tuple{ONBasis, Any, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product","text":"triple_product(ONB::ONBasis, j, k, l; normalize) -> Any\n\n\nEvaluates the triple product of three basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product_y-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product_y","text":"triple_product_y(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the triple product of two basis functions and y.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4poly","text":"vals4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the values of the p-th polynomial at all quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4qp-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4qp","text":"vals4qp(ONB::ONBasis, k) -> Any\n\n\nreturns the values of all polynomials at the k-th quadrature point\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4xref-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.vals4xref","text":"vals4xref(\n    ONB::ONBasis\n) -> StaticArraysCore.SMatrix{nquad, npoly, T} where {T<:Real, npoly, nquad}\n\n\nreturns the values of all polynomials at the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Adaptivity-and-error-control","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"","category":"section"},{"location":"estimators/#Residual-based-a-posteriori-error-estimation","page":"Adaptivity and error control","title":"Residual-based a posteriori error estimation","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Spatial error estimation refers to classical residual-based error estimation for the zero-th multi-index, which corresponds to the mean value. Stochastic error control determines which stochastic mode should be refined, either by increasing the polynomial degree or by activating neighboring stochastic modes. Both are represented by multi-indices. Unified error control enables residual-based error estimation for the subresiduals associated with each multi-index, depending on the model problem (see references on the main page for details).","category":"page"},{"location":"estimators/#ExtendableASGFEM.estimate-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.estimate","text":"estimate(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    kwargs...\n) -> Tuple{DataType, DataType, Vector{Vector{Int64}}}\n\n\nCompute the residual-based a posteriori error estimator for a stochastic Galerkin solution vector sol.\n\nArguments\n\n::Type{AbstractModelProblem}: The model problem type for which the estimator is called. Used for dispatching to the appropriate estimator implementation.\nsol::SGFEVector: The current stochastic Galerkin solution vector.\nC::AbstractStochasticCoefficient: The stochastic coefficient (random field or parameterization).\nrhs: (Optional) Right-hand side function for the PDE (default: nothing).\nbonus_quadorder: (Optional) Additional quadrature order for integration (default: 1).\ntail_extension: (Optional) Number of additional boundary modes to include in the multi-index set (default: 5).\nkwargs...: Additional keyword arguments passed to the estimator.\n\nReturns\n\nA tuple containing:\n\neta4modes::Vector{Float64}: Total error estimator for each multi-index (stochastic mode), corresponding to the enriched set of multi-indices (with current active modes first).\neta4cell::Matrix{Float64}: Error estimator for each cell in the spatial grid (for spatial refinement), for each multi-index.\nmulti_indices_extended: The enriched set of multi-indices used in the computation (including boundary extensions).\n\nDescription\n\nThis function computes a residual-based a posteriori error estimator for the current SGFEM solution. It supports both spatial and stochastic adaptivity by providing error indicators for each cell and each stochastic mode. The estimator is tailored to the model problem and the stochastic coefficient, and can be extended to include additional boundary modes for improved reliability.\n\nIf no specialized estimator is available for the given model problem type, an error is raised and empty arrays are returned. ```\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Multi-index-management","page":"Adaptivity and error control","title":"Multi-index management","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Depending on the model problem and stochastic coefficient, the number of multi-indices to be added for error estimation varies. The following methods assist in enriching the set of multi-indices.","category":"page"},{"location":"estimators/#ExtendableASGFEM.add_boundary_modes-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.add_boundary_modes","text":"add_boundary_modes(\n    multi_indices;\n    p_extension,\n    tail_extension\n) -> Any\n\n\nAdds new stochastic modes (multi-indices) to the current set by extending in several ways:\n\nFor each existing mode, all neighboring modes are added (i.e., all possible copies of that mode where one dimension is increased by 1).\np_extension ensures that the polynomial degree in the first dimension is increased by this amount (adds new modes with higher degree in the first component).\ntail_extension is a two-element vector:\ntail_extension[1]: Adds this many new modes of order 1 (i.e., with a single nonzero entry).\ntail_extension[2]: For each existing mode, also activates or increases the next tail_extension[2] higher stochastic modes in each dimension.\n\nReturns the extended set of multi-indices.\n\nArguments\n\nmulti_indices: The current set of multi-indices (vector of integer vectors).\np_extension: Number of additional degrees to add in the first dimension (default: 1).\ntail_extension: Two-element vector controlling the number and type of new modes to add (default: [10, 2]).\n\nReturns\n\nA new vector containing the extended set of multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.classify_modes","page":"Adaptivity and error control","title":"ExtendableASGFEM.classify_modes","text":"classify_modes(multi_indices) -> NTuple{5, Vector{Int64}}\nclassify_modes(\n    multi_indices,\n    active_modes\n) -> NTuple{5, Vector{Int64}}\n\n\nClassifies all multi-indices into the following categories based on their neighborhood relations:\n\nactive_int: Active mode where all direct neighbors (obtained by increasing any active or next dimension by 1) are also in active_modes.\nactive_bnd: Active mode where not all direct neighbors are in active_modes (i.e., it lies on the active boundary).\ninactive_bnd: Inactive mode that has at least one active neighbor (first layer of inactive modes).\ninactive_bnd2: Inactive mode that has a neighbor in inactive_bnd (second layer of inactive modes).\ninactive_else: All other inactive modes.\n\nArguments\n\nmulti_indices: The set of all multi-indices to classify (vector of integer vectors).\nactive_modes: The set of currently active modes (default: all multi_indices).\n\nReturns\n\nA tuple of five vectors containing the indices of the multi-indices in the following order: (inactive_else, inactive_bnd, inactive_bnd2, active_bnd, active_int).\n\n\n\n\n\n","category":"function"},{"location":"estimators/#ExtendableASGFEM.generate_multiindices-Tuple{Any, Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.generate_multiindices","text":"generate_multiindices(M, deg) -> Any\n\n\ngenerates multi-indices for M dimensions up to degree deg\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.prepare_multi_indices!-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.prepare_multi_indices!","text":"prepare_multi_indices!(multi_indices; minimal_length)\n\n\nensures that all multi-indices have the same length\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Monte-Carlo-sampling-estimator","page":"Adaptivity and error control","title":"Monte Carlo sampling estimator","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"A hierarchical Monte Carlo error estimator is also available. It compares the solution with a higher-order discrete solution for sampled deterministic problems. This is mainly intended to compute a reference error to assess the efficiency of the residual-based error estimator.","category":"page"},{"location":"estimators/#ExtendableASGFEM.calculate_sampling_error-Tuple{SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.calculate_sampling_error","text":"calculate_sampling_error(\n    SolutionSGFEM::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    problem,\n    bonus_quadorder_a,\n    bonus_quadorder_f,\n    order,\n    rhs,\n    dim,\n    Msamples,\n    parallel_sampling,\n    dimensionwise_error,\n    energy_norm,\n    debug,\n    nsamples\n) -> NTuple{4, Vector{Float64}}\n\n\nEstimates the error for the given model problem by Monte Carlo sampling. For each sample, a deterministic finite element solution is computed for a fixed (sampled) coefficient with polynomial order order and compared to the provided stochastic Galerkin solution SolutionSGFEM.\n\nReturns\n\nA tuple of arrays (each of length M+1, where M is the maximum order of the multi-indices):\n\ntotalerrorL2stress_weighted: Mean L2 error of the stress, weighted by the distribution.\ntotalerrorL2u_weighted: Mean L2 error of the solution, weighted by the distribution.\ntotalerrorL2stress_uniform: Mean L2 error of the stress, weighted uniformly.\ntotalerrorL2u_uniform: Mean L2 error of the solution, weighted uniformly.\n\nThe m-th component of these arrays gives the error when only multi-indices up to order m are included.\n\nArguments\n\nSolutionSGFEM: The stochastic Galerkin solution (SGFEVector).\nC: The stochastic coefficient.\nproblem: The model problem type (default: LogTransformedPoissonProblemPrimal).\nbonus_quadorder_a: Additional quadrature order for the coefficient (default: 10).\nbonus_quadorder_f: Additional quadrature order for the right-hand side (default: 0).\norder: Polynomial order for the deterministic reference solution (default: 2).\nrhs: Right-hand side function (optional).\ndim: Spatial dimension (default: inferred from the solution).\nMsamples: Number of random variables to sample (default: maxm(C)).\nparallel_sampling: Whether to use parallel sampling (default: true).\ndimensionwise_error: If true, computes errors dimensionwise (default: false).\nenergy_norm: If true, uses the energy norm for stress error (default: true).\ndebug: If true, enables debug output and plotting (default: false).\nnsamples: Number of Monte Carlo samples (default: 100).\n\nDetails\n\nThis function computes deterministic reference solutions for each sample, then compares them to the SGFEM solution to estimate the error. Both weighted and unweighted (uniform) averages are returned for stress and solution errors.\n\n\n\n\n\n","category":"method"},{"location":"#ExtendableASGFEM","page":"Home","title":"ExtendableASGFEM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an implementation of the stochastic Galerkin finite element method (SGFEM) for selected two-dimensional model problems involving Karhunen-Loève expansions (KLE) of stochastic coefficients. The resulting large-scale systems exhibit a tensorized structure and are efficiently solved using iterative solvers. Adaptive a posteriori error estimators guide both spatial and stochastic refinement to ensure accuracy and efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spatial discretization is performed using the finite element packages ExtendableFEM.jl and ExtendableFEMBase.jl.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"Adaptive stochastic Galerkin FEM\"         M. Eigel, C.J. Gittelson, C. Schwab, E. Zander         CMAME 270, 1 (2014), 247–269         Journal-Link         Preprint-Link\n[2]   \"A posteriori error control for stochastic Galerkin FEM with high-dimensional random parametric PDEs\"         M. Eigel, C. Merdon         To appear in: Error Control, Adaptive Discretizations, and Applications, Part 3, Academic Press         Preprint-Link\n[3]   \"Local equilibration error estimators for guaranteed error control in adaptive higher-order stochastic Galerkin finite element methods\"         M. Eigel and C. Merdon         SIAM/ASA J. Uncertainty Quantification 4(1) (2016), 1372–1397         Journal-Link         Preprint-Link","category":"page"},{"location":"orthogonal_polynomials/#Orthogonal-Polynomials","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"In the stochastic discretization of random variables, global polynomials that are orthogonal with respect to the probability distribution of each random variable y_m are used. These orthogonal polynomials can be generated via recurrence relations, with coefficients determined by the underlying distribution.","category":"page"},{"location":"orthogonal_polynomials/#Recurrence-Relations","page":"Orthogonal Polynomials","title":"Recurrence Relations","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"Orthogonal polynomials H_n with respect to a weight function omega satisfy","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"int_Gamma omega(y) H_n(y) H_m(y) dy = N^2_nmdelta_nm","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"where","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"N_nn =  H_n _omega^2 = int_Gamma omega(y) H_n(y) H_n(y) dy","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"The polynomials satisfy the three-term recurrence relation:","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\n  H_n+2(y)  = (a_n y - b_n) H_n+1(y) - c_n H_n(y)\nendaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"with initial values H_0 = 0 and H_1 = 1.","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate!-Tuple{Any, Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate!","text":"evaluate!(\n    y,\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n)\n\n\nEvaluates the first n+1 orthogonal polynomials of the specified type at a single value x and writes the results into the vector y.\n\nArguments\n\ny: Preallocated vector to store the polynomial values. Must have length at least n+1.\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree to evaluate (computes degrees 0 to n).\nx: The point at which to evaluate the polynomials.\n\nExample\n\ny = zeros(Float64, 6)\nevaluate!(y, HermitePolynomials, 5, 0.0)\n# y now contains H_0(0), H_1(0), ..., H_5(0)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Tuple{Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials of the specified type at a single value x and returns a vector containing the results.\n\nArguments\n\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree to evaluate (computes degrees 0 to n).\nx: The point at which to evaluate the polynomials.\n\nReturns\n\nA vector of length n+1 containing the values [p_0(x), p_1(x), ..., p_n(x)].\n\nExample\n\ny = evaluate(HermitePolynomials, 5, 0.0)\n# y now contains H_0(0), H_1(0), ..., H_5(0)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{Type{<:OrthogonalPolynomialType}, Integer, AbstractVector{T}}} where T","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::AbstractArray{T, 1}\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials at a vector of x\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.normalise_recurrence_coefficients-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.normalise_recurrence_coefficients","text":"normalise_recurrence_coefficients(\n    OBT::Type{<:OrthogonalPolynomialType},\n    k\n) -> Tuple{Any, Any, Any}\n\n\nChanges the recurrence coefficients, such that basis functions are normalized.\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#LinearAlgebra.norm-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"LinearAlgebra.norm","text":"norm(basis::Type{<:OrthogonalPolynomialType}, n; gr) -> Any\n\n\nComputes the norms of the first n+1 orthogonal polynomials of the specified type using Gauss quadrature.\n\nArguments\n\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree for which to compute the norm (computes degrees 0 to n).\ngr: Optional. A Gauss quadrature rule as a tuple (nodes, weights). By default, uses gauss_rule(basis, 2 * n).\n\nReturns\n\nA vector of length n+1 containing the L2 norms [||p_0||, ||p_1||, ..., ||p_n||] of the orthogonal polynomials with respect to the weight function of the basis.\n\nExample\n\nnorms = norm(HermitePolynomials, 3)\n# norms contains the L^2 norms of H_0, H_1, H_2, H_3\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Legendre-Polynomials-(Uniform-Distribution)","page":"Orthogonal Polynomials","title":"Legendre Polynomials (Uniform Distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = 12 on the interval -11 (uniform distribution), the recurrence coefficients are a_n = (2n+1)(n+1), b_n = 0, and c_n = n(n+1). The norms of the resulting Legendre polynomials are","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = frac22n+1","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.LegendrePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.LegendrePolynomials","text":"abstract type LegendrePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Legendre polynomials, which are orthogonal with respect to the uniform distribution on [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{LegendrePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{LegendrePolynomials}\n) -> Distributions.Uniform{Float64}\n\n\nReturns the probability distribution associated with the Legendre polynomials, which is the uniform distribution on [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{LegendrePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{LegendrePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Legendre polynomial, i.e.,\n\n||P_k|| = sqrt(2 / (2k + 1))\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{LegendrePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{LegendrePolynomials},\n    k::Integer\n) -> Tuple{Int64, Any, Any}\n\n\nReturns the recurrence coefficients (a, b, c) for the k-th Legendre polynomial, corresponding to the three-term recurrence relation:\n\nP_{k+1}(x) = (a_k x - b_k) P_k(x) - c_k P_{k-1}(x)\n\nFor Legendre polynomials:\n\na = 0\nb = (2k + 1) / (k + 1)\nc = k / (k + 1)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Hermite-Polynomials-(Normal-Distribution)","page":"Orthogonal Polynomials","title":"Hermite Polynomials (Normal Distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = exp(-y^22)(2pi) (normal distribution), the recurrence coefficients are a_n = 1, b_n = 0, and c_n = n. The first six Hermite polynomials are:","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\nH_0  = 0\nH_1  = 1\nH_2  = y\nH_3  = y^2 - 1\nH_4  = y^3 - 3y\nH_5  = y^4 - 6y^2 + 3\nendaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"Their norms are given by","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = n","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.HermitePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.HermitePolynomials","text":"abstract type HermitePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Hermite polynomials, which are orthogonal with respect to the standard normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{HermitePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{HermitePolynomials}\n) -> Distributions.Normal{Float64}\n\n\nReturns the probability distribution associated with the Hermite polynomials, which is the standard normal distribution Normal(0, 1).\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{HermitePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{HermitePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Hermite polynomial, i.e.,\n\n||H_k|| = sqrt(k!)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{HermitePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{HermitePolynomials},\n    k::Integer\n) -> Tuple{Int64, Int64, Integer}\n\n\nReturns the recurrence coefficients (a, b, c) for the k-th Hermite polynomial, corresponding to the three-term recurrence relation:\n\nH_{k+1}(x) = (a_k x - b_k) H_k(x) - c_k H_{k-1}(x)\n\nFor Hermite polynomials:\n\na = 0\nb = 1\nc = k\n\n\n\n\n\n","category":"method"}]
}
