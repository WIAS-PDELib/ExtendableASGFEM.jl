var documenterSearchIndex = {"docs":
[{"location":"sgfem/#Overview","page":"SGFEM Overview","title":"Overview","text":"","category":"section"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"This page gives a concise overview of the main building blocks  of the stochastic Galerkin (SG) methods implemented in this repository.","category":"page"},{"location":"sgfem/#Key-blocks","page":"SGFEM Overview","title":"Key blocks","text":"","category":"section"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"Represent uncertain coefficients/inputs by a finite parametric expansion (e.g. Karhunen–Loève / KL expansion).\nExpand the solution unknowns in a tensor product of a spatial finite element basis and a stochastic polynomial basis (Galerkin ansatz).\nGalerkin project onto the combined basis to obtain a coupled deterministic system for the expansion coefficients.\nSolve the system with solvers that exploit the tensor/block structure.\nAdaptivity in space and in the stochastic index set to reduce costs.","category":"page"},{"location":"sgfem/#Example:-Parametric-Poisson-Problem","page":"SGFEM Overview","title":"Example: Parametric Poisson Problem","text":"","category":"section"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"To illustrate the workflow, consider a Poisson problem with parametric diffusion coefficient:","category":"page"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"-mathrmdiv(a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D","category":"page"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"where the coefficient has the Karhunen-Loève expansion:","category":"page"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"a(yx) = a_0(x) + sum_m=1^M sqrtlambda_m phi_m(x) y_m","category":"page"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"with mean field a_0, eigenpairs (lambda_mphi_m) and parameters y_m in -11.","category":"page"},{"location":"sgfem/#Stochastic-Galerkin-Formulation","page":"SGFEM Overview","title":"Stochastic Galerkin Formulation","text":"","category":"section"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"Expand the solution in tensorized basis functions:\nu(yx) = sum_mu u_mu(x) H_mu(y)\nwhere H_mu(y) = prod_m=1^M H_mu_m(y_m) are multivariate Legendre polynomials.\nGalerkin projection yields the weak form:\nsum_mu int_Gamma a(yx) nabla u_mu(x) cdot nabla v(x) H_mu(y) H_nu(y)dy = int_Gamma f(x)v(x) H_nu(y)dy\nfor all test functions v(x) and indices nu.\nThis results in a coupled block system mathbfAmathbfu = mathbfb where:\nEach block mathbfA_munu involves the mean and KL terms of a(yx)\nThe tensor structure allows efficient matrix-free operations","category":"page"},{"location":"sgfem/#Where-to-find-documentation/implementations-of-the-key-blocks","page":"SGFEM Overview","title":"Where to find documentation/implementations of the key blocks","text":"","category":"section"},{"location":"sgfem/","page":"SGFEM Overview","title":"SGFEM Overview","text":"Parametric model / KL representation of the random coefficient.\nSee:\nStochastic coefficients — available random coefficients and polynomial chaos expansions.\nModel problems — available model problems that involve random coefficients. See also source: src/modelproblems/.\nChoose stochastic basis, orthogonal polynomials, suitable for the parameter space\nSee:\nOrthogonal polynomials and recurrence relations — Legendre / Hermite polynomials and recurrence coefficients.\nONBasis (one-dimensional orthonormal basis) — construction and utilities for evaluating 1D orthonormal polynomial bases (norms, quadrature, evaluations).\nTensorized / multivariate basis (TensorizedBasis) — assembling multivariate bases from ONBasis instances and precomputing triple products.\nBuild spatial FE spaces and blocks of system matrix.\nUse FESpace types (H1, HDIV, ...) from the ExtendableFEM ecosystem.\nSee: ExtendableFEMBase.jl — basis finite-element spaces, basis evaluations and low-level FE utilities like standard interpolations.\nSee: ExtendableFEM.jl — high-level deterministic operator assembly and helpers used throughout the codebase.\nAssemble and solve the full SG system\nGalerkin projection yields a coupled deterministic block system. Briefly:\nExpand u(y,x)=∑μ uμ(x) Hμ(y), test with Hν ⇒ block matrix with entries a_{μ,ν} A(·).\nSolver choices:\ndirect assembly + dense solver (for debugging / small problems)\nmatrix‑free iterative solvers exploiting tensor/block structure + preconditioners\nSee problem solver implementations: src/modelproblems/solvers_*.jl.\nPostprocessing, error estimation & adaptivity\nError estimators and marking criteria implemented in the script driver scripts/poisson.jl for the available Poisson model problems.\nError estimators are problem-dependent and can be currently found in src/estimate.jl\nSpatial (mesh refinement) uses refinement routines from ExtendableFEMBase.jl\nStochastic refinement (enrich multi‑index set) uses functions from src/mopcontrol.jl\nsee documentation page on Estimators for some more details\nResults, parameters and reproducible outputs are stored with DrWatson (see scripts/poisson.jl for naming pattern).","category":"page"},{"location":"estimators/#Adaptivity-and-error-control","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"","category":"section"},{"location":"estimators/#Residual-based-a-posteriori-error-estimation","page":"Adaptivity and error control","title":"Residual-based a posteriori error estimation","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Spatial error estimation refers to classical residual-based error estimation for the zero-th multi-index, which corresponds to the mean value. Stochastic error control determines which stochastic mode should be refined, either by increasing the polynomial degree or by activating neighboring stochastic modes. Both are represented by multi-indices. Unified error control enables residual-based error estimation for the subresiduals associated with each multi-index, depending on the model problem (see references on the main page for details).","category":"page"},{"location":"estimators/#ExtendableASGFEM.estimate-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.estimate","text":"estimate(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    kwargs...\n) -> Tuple{DataType, DataType, Vector{Vector{Int64}}}\n\n\nCompute the residual-based a posteriori error estimator for a stochastic Galerkin solution vector sol.\n\nArguments\n\n::Type{AbstractModelProblem}: The model problem type for which the estimator is called. Used for dispatching to the appropriate estimator implementation.\nsol::SGFEVector: The current stochastic Galerkin solution vector.\nC::AbstractStochasticCoefficient: The stochastic coefficient (random field or parameterization).\nrhs: (Optional) Right-hand side function for the PDE (default: nothing).\nbonus_quadorder: (Optional) Additional quadrature order for integration (default: 1).\ntail_extension: (Optional) Number of additional boundary modes to include in the multi-index set (default: 5).\nkwargs...: Additional keyword arguments passed to the estimator.\n\nReturns\n\nA tuple containing:\n\neta4modes::Vector{Float64}: Total error estimator for each multi-index (stochastic mode), corresponding to the enriched set of multi-indices (with current active modes first).\neta4cell::Matrix{Float64}: Error estimator for each cell in the spatial grid (for spatial refinement), for each multi-index.\nmulti_indices_extended: The enriched set of multi-indices used in the computation (including boundary extensions).\n\nDescription\n\nThis function computes a residual-based a posteriori error estimator for the current SGFEM solution. It supports both spatial and stochastic adaptivity by providing error indicators for each cell and each stochastic mode. The estimator is tailored to the model problem and the stochastic coefficient, and can be extended to include additional boundary modes for improved reliability.\n\nIf no specialized estimator is available for the given model problem type, an error is raised and empty arrays are returned. ```\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Multi-index-management","page":"Adaptivity and error control","title":"Multi-index management","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Depending on the model problem and stochastic coefficient, the number of multi-indices to be added for error estimation varies. The following methods assist in enriching the set of multi-indices.","category":"page"},{"location":"estimators/#ExtendableASGFEM.add_boundary_modes-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.add_boundary_modes","text":"add_boundary_modes(\n    multi_indices;\n    p_extension,\n    tail_extension\n) -> Any\n\n\nAdds new stochastic modes (multi-indices) to the current set by extending in several ways:\n\nFor each existing mode, all neighboring modes are added (i.e., all possible copies of that mode where one dimension is increased by 1).\np_extension ensures that the polynomial degree in the first dimension is increased by this amount (adds new modes with higher degree in the first component).\ntail_extension is a two-element vector:\ntail_extension[1]: Adds this many new modes of order 1 (i.e., with a single nonzero entry).\ntail_extension[2]: For each existing mode, also activates or increases the next tail_extension[2] higher stochastic modes in each dimension.\n\nReturns the extended set of multi-indices.\n\nArguments\n\nmulti_indices: The current set of multi-indices (vector of integer vectors).\np_extension: Number of additional degrees to add in the first dimension (default: 1).\ntail_extension: Two-element vector controlling the number and type of new modes to add (default: [10, 2]).\n\nReturns\n\nA new vector containing the extended set of multi-indices.\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.classify_modes","page":"Adaptivity and error control","title":"ExtendableASGFEM.classify_modes","text":"classify_modes(multi_indices) -> NTuple{5, Vector{Int64}}\nclassify_modes(\n    multi_indices,\n    active_modes\n) -> NTuple{5, Vector{Int64}}\n\n\nClassifies all multi-indices into the following categories based on their neighborhood relations:\n\nactive_int: Active mode where all direct neighbors (obtained by increasing any active or next dimension by 1) are also in active_modes.\nactive_bnd: Active mode where not all direct neighbors are in active_modes (i.e., it lies on the active boundary).\ninactive_bnd: Inactive mode that has at least one active neighbor (first layer of inactive modes).\ninactive_bnd2: Inactive mode that has a neighbor in inactive_bnd (second layer of inactive modes).\ninactive_else: All other inactive modes.\n\nArguments\n\nmulti_indices: The set of all multi-indices to classify (vector of integer vectors).\nactive_modes: The set of currently active modes (default: all multi_indices).\n\nReturns\n\nA tuple of five vectors containing the indices of the multi-indices in the following order: (inactive_else, inactive_bnd, inactive_bnd2, active_bnd, active_int).\n\n\n\n\n\n","category":"function"},{"location":"estimators/#ExtendableASGFEM.generate_multiindices-Tuple{Any, Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.generate_multiindices","text":"generate_multiindices(M, deg) -> Any\n\n\ngenerates multi-indices for M dimensions up to degree deg\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.prepare_multi_indices!-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.prepare_multi_indices!","text":"prepare_multi_indices!(multi_indices; minimal_length)\n\n\nensures that all multi-indices have the same length\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Monte-Carlo-sampling-estimator","page":"Adaptivity and error control","title":"Monte Carlo sampling estimator","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"A hierarchical Monte Carlo error estimator is also available. It compares the solution with a higher-order discrete solution for sampled deterministic problems. This is mainly intended to compute a reference error to assess the efficiency of the residual-based error estimator.","category":"page"},{"location":"estimators/#ExtendableASGFEM.calculate_sampling_error-Tuple{SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.calculate_sampling_error","text":"calculate_sampling_error(\n    SolutionSGFEM::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    problem,\n    bonus_quadorder_a,\n    bonus_quadorder_f,\n    order,\n    rhs,\n    dim,\n    Msamples,\n    parallel_sampling,\n    dimensionwise_error,\n    energy_norm,\n    debug,\n    nsamples\n) -> NTuple{4, Vector{Float64}}\n\n\nEstimates the error for the given model problem by Monte Carlo sampling. For each sample, a deterministic finite element solution is computed for a fixed (sampled) coefficient with polynomial order order and compared to the provided stochastic Galerkin solution SolutionSGFEM.\n\nReturns\n\nA tuple of arrays (each of length M+1, where M is the maximum order of the multi-indices):\n\ntotalerrorL2stress_weighted: Mean L2 error of the stress, weighted by the distribution.\ntotalerrorL2u_weighted: Mean L2 error of the solution, weighted by the distribution.\ntotalerrorL2stress_uniform: Mean L2 error of the stress, weighted uniformly.\ntotalerrorL2u_uniform: Mean L2 error of the solution, weighted uniformly.\n\nThe m-th component of these arrays gives the error when only multi-indices up to order m are included.\n\nArguments\n\nSolutionSGFEM: The stochastic Galerkin solution (SGFEVector).\nC: The stochastic coefficient.\nproblem: The model problem type (default: LogTransformedPoissonProblemPrimal).\nbonus_quadorder_a: Additional quadrature order for the coefficient (default: 10).\nbonus_quadorder_f: Additional quadrature order for the right-hand side (default: 0).\norder: Polynomial order for the deterministic reference solution (default: 2).\nrhs: Right-hand side function (optional).\ndim: Spatial dimension (default: inferred from the solution).\nMsamples: Number of random variables to sample (default: maxm(C)).\nparallel_sampling: Whether to use parallel sampling (default: true).\ndimensionwise_error: If true, computes errors dimensionwise (default: false).\nenergy_norm: If true, uses the energy norm for stress error (default: true).\ndebug: If true, enables debug output and plotting (default: false).\nnsamples: Number of Monte Carlo samples (default: 100).\n\nDetails\n\nThis function computes deterministic reference solutions for each sample, then compares them to the SGFEM solution to estimate the error. Both weighted and unweighted (uniform) averages are returned for stress and solution errors.\n\n\n\n\n\n","category":"method"},{"location":"poisson_script/#Script-on-Poisson-Problems","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"The script scripts/poisson.jl provides an implementation of adaptive stochastic Galerkin FEM for various formulations of the parametric Poisson problem.","category":"page"},{"location":"poisson_script/#Available-Problem-Types","page":"Script on Poisson Problems","title":"Available Problem Types","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"PoissonProblemPrimal: Standard Poisson problem with linear coefficient a\nLogTransformedPoissonProblemPrimal: Log-transformed Poisson problem with exponential coefficient exp(a)\nLogTransformedPoissonProblemDual: Dual formulation of the log-transformed problem (WIP)","category":"page"},{"location":"poisson_script/#Usage","page":"Script on Poisson Problems","title":"Usage","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"The main function to run experiments is:","category":"page"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"run(; problem = problem_type, kwargs...)","category":"page"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"Results can be loaded and visualized using:","category":"page"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"show_results(; kwargs...)    # show results and statistics\nproduce_plots(; kwargs...)   # generate convergence and other plots","category":"page"},{"location":"poisson_script/#Parameters","page":"Script on Poisson Problems","title":"Parameters","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"The following parameters can be specified (with their defaults):","category":"page"},{"location":"poisson_script/#Problem-Configuration","page":"Script on Poisson Problems","title":"Problem Configuration","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"problem = LogTransformedPoissonProblemPrimal: Problem type to solve\ndomain = \"square\": Domain shape (\"square\" or \"lshape\")\norder = 1: Polynomial order of finite elements\ninitial_refs = 1: Initial uniform mesh refinements","category":"page"},{"location":"poisson_script/#Stochastic-Parameters","page":"Script on Poisson Problems","title":"Stochastic Parameters","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"C = StochasticCoefficientCosinus: Type of stochastic coefficient\ndecay = 2: Decay rate of the coefficient expansion\nmean = 0: Mean value of the coefficient\nmaxm = 150: Maximum number of terms in coefficient expansion\ninitial_modes = [[0]]: Initial active stochastic modes","category":"page"},{"location":"poisson_script/#Adaptive-Parameters","page":"Script on Poisson Problems","title":"Adaptive Parameters","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"θ_stochastic = 0.5: Marking parameter for stochastic refinement\nθ_spatial = 0.5: Marking parameter for spatial refinement\nfactor_tail = 1: Factor for tail estimator comparison\ntail_extension = [10, 2]: Extension parameters for [0] mode and others\nmaxdofs = 1.0e4: Maximum degrees of freedom\nnsamples = 150: Number of samples for error computation\nuse_equilibration_estimator = false: Use equilibration error estimator instead of standard residual estimator","category":"page"},{"location":"poisson_script/#Solver-Options","page":"Script on Poisson Problems","title":"Solver Options","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"use_iterative_solver = true: Use iterative solver (instead of a direct solver with full matrix)\nbonus_quadorder_a = 2: Additional quadrature order for coefficient\nbonus_quadorder_f = 0: Additional quadrature order for right-hand side","category":"page"},{"location":"poisson_script/#Right-Hand-Side","page":"Script on Poisson Problems","title":"Right-Hand Side","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"f = (result, qpinfo) -> (result[1] = 1): Right-hand side function","category":"page"},{"location":"poisson_script/#Visualization","page":"Script on Poisson Problems","title":"Visualization","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"Plotter = nothing: Plotting backend (e.g., CairoMakie)","category":"page"},{"location":"poisson_script/#Results-Storage","page":"Script on Poisson Problems","title":"Results Storage","text":"","category":"section"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"Results are automatically stored using DrWatson.jl in the data folder. The filename includes most problem parameters for reproducibility:","category":"page"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"data/[problem]/[domain]/order=[order]_maxdofs=[maxdofs]_decay=[decay]_mean=[mean]_θ=([θ_spatial],[θ_stochastic])_tail=[tail_extension]","category":"page"},{"location":"poisson_script/","page":"Script on Poisson Problems","title":"Script on Poisson Problems","text":"If the equilibration estimator is used, _eq is appended to the filename.","category":"page"},{"location":"plots/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The following special plot functions are available and basically delegate to the plotting routines from ExtendableFEM/GridVisualize.","category":"page"},{"location":"plots/#ExtendableASGFEM.plot_basis-Union{Tuple{ONBasis{T, OBT, npoly, nquad}}, Tuple{nquad}, Tuple{npoly}, Tuple{OBT}, Tuple{T}} where {T, OBT, npoly, nquad}","page":"Plotting","title":"ExtendableASGFEM.plot_basis","text":"plot_basis(\n    ONB::ONBasis{T, OBT, npoly, nquad};\n    Plotter,\n    resolution,\n    kwargs...\n)\n\n\nplots the basis functions of the ONBasis ONB via GridVisualize. The Plotter argument determines the backend (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"plots/#ExtendableASGFEM.plot_modes-Tuple{SGFEVector}","page":"Plotting","title":"ExtendableASGFEM.plot_modes","text":"plot_modes(\n    sol::SGFEVector;\n    unknown,\n    Plotter,\n    nmodes,\n    ncols,\n    width,\n    sort\n) -> GridVisualize.GridVisualizer\n\n\nPlot scalar plots of the stochastic modes of an SGFEVector solution using ExtendableFEM.plots.GridVisualize.\n\nArguments\n\nsol::SGFEVector: The stochastic Galerkin finite element solution vector whose modes are to be visualized.\nunknown: (Optional, default: 1) Index of the unknown to plot (for multi-unknown systems).\nPlotter: (Optional) Plotting backend to use (e.g., GLMakie, CairoMakie, PyPlot, Plots).\nnmodes: (Optional) Number of stochastic modes to plot (default: all modes in the tensorized basis).\nncols: (Optional, default: 3) Number of columns in the plot grid.\nwidth: (Optional) Total width of the plot grid in pixels (default: 400 * ncols).\nsort: (Optional, default: false) If true, modes are sorted by their L2 norm (largest first).\n\nExample\n\nplot_modes(sol; Plotter=GLMakie, ncols=4, sort=true)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"Solving a problem requires both spatial and stochastic discretization. These are combined into a specialized vector structure, which is then passed to a solver function that executes an iterative algorithm tailored to each model problem.","category":"page"},{"location":"solvers/#SGFEVector","page":"Solver","title":"SGFEVector","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"The spatial discretization is defined by a single finite element space from ExtendableFEM.jl, while the stochastic discretization uses a tensorized basis for the parameter space of the stochastic coefficient. Both components must be set up in advance.","category":"page"},{"location":"solvers/","page":"Solver","title":"Solver","text":"note: Note\nCurrently, it is not possible to use different finite element spaces for different multi-indices. This feature may be added in the future.","category":"page"},{"location":"solvers/#ExtendableASGFEM.SGFEVector","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"struct SGFEVector{T, Tv, Ti, ONBType<:ONBasis, MIType}\n\nA structure that extends ExtendableFEMBase.FEVector to include information about the stochastic discretization, specifically the associated TensorizedBasis.\n\nFields\n\nFES_space: Array of finite element spaces for all stochastic modes.\nTB: The tensorized basis used for the stochastic discretization.\nactive_modes: Indices of the active stochastic modes (with respect to TB.multi_indices).\nlength4modes: Offsets for each mode in the global vector.\nFEVectorBlocks: Vector block mask for each multi-index (stochastic mode).\nentries: The full coefficient vector containing all degrees of freedom.\nlast_sample: The last sample used for evaluation (for efficient repeated evaluation).\nFEV: An FEVector used for evaluating the SGFEVector at a given sample.\n\nThis structure enables efficient storage, evaluation, and manipulation of solutions in stochastic Galerkin finite element methods.\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ExtendableASGFEM.SGFEVector-Union{Tuple{MIType}, Tuple{ONBType}, Tuple{Ti}, Tuple{Tv}, Tuple{Vector{<:ExtendableFEMBase.FESpace{Tv, Ti}}, TensorizedBasis{Tv, ONBType, MIType}}} where {Tv, Ti, ONBType, MIType}","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"SGFEVector(\n    FES::Array{<:ExtendableFEMBase.FESpace{Tv, Ti}, 1},\n    TB::TensorizedBasis{Tv, ONBType, MIType};\n    active_modes,\n    T,\n    unames\n) -> SGFEVector\n\n\nConstructs an SGFEVector for the given spatial finite element spaces FES and the tensorized basis TB representing the stochastic discretization.\n\nArguments\n\nFES: Array of finite element spaces (one for each unknown).\nTB: The tensorized basis for the stochastic discretization.\nactive_modes: Indices of the active stochastic modes to include (default: all modes in TB).\nT: The floating-point type for the coefficient vector (default: Tv).\nunames: Names or identifiers for the unknowns (default: 1:length(FES)).\n\nReturns\n\nAn SGFEVector object that stores the spatial and stochastic discretization, the coefficient vector, and all necessary metadata for efficient evaluation and manipulation in stochastic Galerkin FEM.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    u::Int64,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the FEVectorBlock for the i-th stochastic mode of the u-th unknown\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the i-th stochastic mode\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.length-Tuple{SGFEVector}","page":"Solver","title":"Base.length","text":"length(SGFEV::SGFEVector) -> Int64\n\n\nreturns the length of the full vector, i.e., the total number of degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.show-Tuple{IO, SGFEVector}","page":"Solver","title":"Base.show","text":"show(io::IO, SGFEV::SGFEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.size-Tuple{SGFEVector}","page":"Solver","title":"Base.size","text":"size(SGFEV::SGFEVector)\n\n\nreturns a tuple with the number of active stochastic modes and the number of spatial degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.fetypes-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.fetypes","text":"fetypes(SGFEV::SGFEVector) -> Vector\n\n\nreturns the finite element types of the (spatial) FE spaces\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.num_multiindices-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(SGFEV::SGFEVector) -> Int64\n\n\nreturns the number of active modes (that are used from the stored tensorized basis)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.set_sample!-Tuple{SGFEVector, AbstractVector}","page":"Solver","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(SGFEV::SGFEVector, S::AbstractVector)\n\n\nEvaluates the SGFEVector at the given sample S and stores the result in SGFEV.FEV.\n\nArguments\n\nSGFEV: The stochastic Galerkin finite element vector to evaluate.\nS: A vector representing the sample (values for the stochastic variables).\n\nDetails\n\nThe sample S is stored in SGFEV.last_sample (truncated or padded as needed).\nThe tensorized basis is evaluated at S, and the resulting coefficients are used to assemble the spatial solution in SGFEV.FEV.\nThis enables efficient evaluation of the SGFEM solution at arbitrary points in the stochastic parameter space.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solve-Function","page":"Solver","title":"Solve Function","text":"","category":"section"},{"location":"solvers/#ExtendableASGFEM.solve!-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Solver","title":"ExtendableASGFEM.solve!","text":"solve!(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    rhs,\n    use_iterative_solver,\n    bonus_quadorder_f,\n    bonus_quadorder_a,\n    kwargs...\n)\n\n\nSolves the specified model problem using the provided stochastic coefficient C and right-hand side rhs, writing the solution into sol.\n\nThe sol vector communicates both the spatial and stochastic discretization, as well as any initial data required for the iterative solver.\n\nIf use_iterative_solver (default: true) is set, an iterative solver is used. Otherwise, the full system matrix is assembled and solved directly (note: this is very slow for large systems).\nThe parameters bonus_quadorder_f (default: 0) and bonus_quadorder_a (default: 2) allow you to increase the quadrature order for terms involving the right-hand side or the stochastic coefficient, respectively.\nAdditional keyword arguments can be passed via kwargs.\n\nIf no solver is implemented for the given model problem, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#TensorizedBasis","page":"TensorizedBasis","title":"TensorizedBasis","text":"","category":"section"},{"location":"tonbasis/","page":"TensorizedBasis","title":"TensorizedBasis","text":"Each multi-index mu = mu_1 mu_2 ldots mu_M defines a tensorized basis function for the parameter space of the form H_mu = prod_k=1^M H_k, where each H_k is an orthogonal polynomial.","category":"page"},{"location":"tonbasis/","page":"TensorizedBasis","title":"TensorizedBasis","text":"The TensorizedBasis object collects all information required to evaluate these basis functions, including the set of multi-indices and the triple products of the form (y_m H_mu H_lambda) for each m and mu lambda in the set of multi-indices, stored as a sparse matrix. While analytic formulas exist to compute these triple products using recurrence coefficients, storing them can significantly speed up evaluations.","category":"page"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"TensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder;\n    ...\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\nTensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder,\n    maxquadorder;\n    T,\n    multi_indices\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\n\nconstructor for a tensorized basis for the given OrthogonalPolynomialType. If no multi-indices are provided it automatically generates all multi-indices up to support length M and polynomial order maxorder.\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis-2","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"struct TensorizedBasis{T<:Real, ONBType<:ONBasis, MIType}\n\nA structure representing a tensorized orthogonal polynomial basis for stochastic Galerkin methods, associated with a given set of multi-indices.\n\nFields\n\nONB::ONBType: The underlying univariate orthogonal basis (e.g., Hermite, Legendre).\nvals::Vector{Vector{T}}: Cached evaluations of the univariate basis functions at the most recent sample(s).\nnmodes::Int: Number of multi-indices (i.e., the number of stochastic modes).\nG::ExtendableSparseMatrix{T, Int64}: Coupling matrix encoding triple products or recurrence relations between basis functions.\nmulti_indices::MIType: Collection of multi-indices (typically an array of integer arrays), each representing a multi-dimensional polynomial degree.\n\nDescription\n\nThe TensorizedBasis type encapsulates all information required to evaluate and manipulate a tensor-product polynomial basis in multiple stochastic dimensions. It supports efficient evaluation, storage of basis values, and access to coupling coefficients for use in stochastic Galerkin finite element methods (SGFEM).\n\nExample\n\n# Construct a tensorized Hermite basis with 3 variables and total degree 2\nTB = TensorizedBasis(HermitePolynomials, 3, 2, 2)\n\n# Evaluate all basis functions at a sample point\nset_sample!(TB, [0.1, -0.2, 0.3])\n\n# Get the value of the 5th basis function at the current sample\nval = evaluate(TB, 5)\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#Base.show-Tuple{IO, TensorizedBasis}","page":"TensorizedBasis","title":"Base.show","text":"show(io::IO, TB::TensorizedBasis)\n\n\nshows information on the tensorized basis.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.distribution-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.distribution","text":"distribution(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns distribution associated to the orthogonal basis\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(TB::TensorizedBasis{T}, j) -> Any\n\n\nevaluates the basis function for the j-th multi-index at the sample that was set with set_sample.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_coupling_coefficient-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any, Any, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.get_coupling_coefficient","text":"get_coupling_coefficient(\n    TB::TensorizedBasis{T},\n    m,\n    j,\n    k\n) -> Any\n\n\nreturns the triple products between y_m and H_j and H_k for two multi-indices j and k.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_multiindex-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.get_multiindex","text":"get_multiindex(TB::TensorizedBasis, j) -> Any\n\n\nreturns the j-th multi-index.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.maxlength_multiindices-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.maxlength_multiindices","text":"maxlength_multiindices(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns the maximal length of the stored multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.num_multiindices-Tuple{TensorizedBasis}","page":"TensorizedBasis","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(TB::TensorizedBasis) -> Int64\n\n\nreturns the number of multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.sample_distribution-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.sample_distribution","text":"sample_distribution(\n    TB::TensorizedBasis,\n    nsamples;\n    M,\n    Mweights\n) -> Tuple{Matrix{Float64}, Any}\n\n\nGenerate samples and weights for the distribution of the ON basis that the tensorized basis is based upon (that can be used for a Monte-Carlo estimator).\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.set_sample!-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(\n    TB::TensorizedBasis,\n    x;\n    normalize\n) -> Array{Vector{T}, 1} where T<:Real\n\n\nevaluates all basis functions at sample vector x; call this before using evaluate!\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Orthogonal-Polynomials","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"In the stochastic discretization of random variables, global polynomials that are orthogonal with respect to the probability distribution of each random variable y_m are used. These orthogonal polynomials can be generated via recurrence relations, with coefficients determined by the underlying distribution.","category":"page"},{"location":"orthogonal_polynomials/#Recurrence-Relations","page":"Orthogonal Polynomials","title":"Recurrence Relations","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"Orthogonal polynomials H_n with respect to a weight function omega satisfy","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"int_Gamma omega(y) H_n(y) H_m(y) dy = N^2_nmdelta_nm","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"where","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"N_nn =  H_n _omega^2 = int_Gamma omega(y) H_n(y) H_n(y) dy","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"The polynomials satisfy the three-term recurrence relation:","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\n  H_n+2(y)  = (a_n y - b_n) H_n+1(y) - c_n H_n(y)\nendaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"with initial values H_0 = 0 and H_1 = 1.","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate!-Tuple{Any, Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate!","text":"evaluate!(\n    y,\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n)\n\n\nEvaluates the first n+1 orthogonal polynomials of the specified type at a single value x and writes the results into the vector y.\n\nArguments\n\ny: Preallocated vector to store the polynomial values. Must have length at least n+1.\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree to evaluate (computes degrees 0 to n).\nx: The point at which to evaluate the polynomials.\n\nExample\n\ny = zeros(Float64, 6)\nevaluate!(y, HermitePolynomials, 5, 0.0)\n# y now contains H_0(0), H_1(0), ..., H_5(0)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Tuple{Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials of the specified type at a single value x and returns a vector containing the results.\n\nArguments\n\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree to evaluate (computes degrees 0 to n).\nx: The point at which to evaluate the polynomials.\n\nReturns\n\nA vector of length n+1 containing the values [p_0(x), p_1(x), ..., p_n(x)].\n\nExample\n\ny = evaluate(HermitePolynomials, 5, 0.0)\n# y now contains H_0(0), H_1(0), ..., H_5(0)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{Type{<:OrthogonalPolynomialType}, Integer, AbstractVector{T}}} where T","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::AbstractArray{T, 1}\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials at a vector of x\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.normalise_recurrence_coefficients-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.normalise_recurrence_coefficients","text":"normalise_recurrence_coefficients(\n    OBT::Type{<:OrthogonalPolynomialType},\n    k\n) -> Tuple{Any, Any, Any}\n\n\nChanges the recurrence coefficients, such that basis functions are normalized.\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#LinearAlgebra.norm-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"LinearAlgebra.norm","text":"norm(basis::Type{<:OrthogonalPolynomialType}, n; gr) -> Any\n\n\nComputes the norms of the first n+1 orthogonal polynomials of the specified type using Gauss quadrature.\n\nArguments\n\nbasis: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nn: The highest polynomial degree for which to compute the norm (computes degrees 0 to n).\ngr: Optional. A Gauss quadrature rule as a tuple (nodes, weights). By default, uses gauss_rule(basis, 2 * n).\n\nReturns\n\nA vector of length n+1 containing the L2 norms [||p_0||, ||p_1||, ..., ||p_n||] of the orthogonal polynomials with respect to the weight function of the basis.\n\nExample\n\nnorms = norm(HermitePolynomials, 3)\n# norms contains the L^2 norms of H_0, H_1, H_2, H_3\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Legendre-Polynomials-(Uniform-Distribution)","page":"Orthogonal Polynomials","title":"Legendre Polynomials (Uniform Distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = 12 on the interval -11 (uniform distribution), the recurrence coefficients are a_n = (2n+1)(n+1), b_n = 0, and c_n = n(n+1). The norms of the resulting Legendre polynomials are","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = frac22n+1","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.LegendrePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.LegendrePolynomials","text":"abstract type LegendrePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Legendre polynomials, which are orthogonal with respect to the uniform distribution on [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{LegendrePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{LegendrePolynomials}\n) -> Distributions.Uniform{Float64}\n\n\nReturns the probability distribution associated with the Legendre polynomials, which is the uniform distribution on [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{LegendrePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{LegendrePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Legendre polynomial, i.e.,\n\n||P_k|| = sqrt(2 / (2k + 1))\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{LegendrePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{LegendrePolynomials},\n    k::Integer\n) -> Tuple{Int64, Any, Any}\n\n\nReturns the recurrence coefficients (a, b, c) for the k-th Legendre polynomial, corresponding to the three-term recurrence relation:\n\nP_{k+1}(x) = (a_k x - b_k) P_k(x) - c_k P_{k-1}(x)\n\nFor Legendre polynomials:\n\na = 0\nb = (2k + 1) / (k + 1)\nc = k / (k + 1)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Hermite-Polynomials-(Normal-Distribution)","page":"Orthogonal Polynomials","title":"Hermite Polynomials (Normal Distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = exp(-y^22)(2pi) (normal distribution), the recurrence coefficients are a_n = 1, b_n = 0, and c_n = n. The first six Hermite polynomials are:","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\nH_0  = 0\nH_1  = 1\nH_2  = y\nH_3  = y^2 - 1\nH_4  = y^3 - 3y\nH_5  = y^4 - 6y^2 + 3\nendaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"Their norms are given by","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = n","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.HermitePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.HermitePolynomials","text":"abstract type HermitePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Hermite polynomials, which are orthogonal with respect to the standard normal distribution.\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{HermitePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{HermitePolynomials}\n) -> Distributions.Normal{Float64}\n\n\nReturns the probability distribution associated with the Hermite polynomials, which is the standard normal distribution Normal(0, 1).\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{HermitePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{HermitePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Hermite polynomial, i.e.,\n\n||H_k|| = sqrt(k!)\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{HermitePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{HermitePolynomials},\n    k::Integer\n) -> Tuple{Int64, Int64, Integer}\n\n\nReturns the recurrence coefficients (a, b, c) for the k-th Hermite polynomial, corresponding to the three-term recurrence relation:\n\nH_{k+1}(x) = (a_k x - b_k) H_k(x) - c_k H_{k-1}(x)\n\nFor Hermite polynomials:\n\na = 0\nb = 1\nc = k\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#Stochastic-Coefficients","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"Stochastic coefficients play a central role in uncertainty quantification and stochastic finite element methods. In this package, coefficients are represented using a Karhunen-Loève expansion (KLE), which allows for the efficient representation of random fields with prescribed covariance structure.","category":"page"},{"location":"coefficients/#Overview","page":"Stochastic Coefficients","title":"Overview","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"The Karhunen-Loève expansion expresses a stochastic process as a series of orthogonal functions weighted by uncorrelated random variables:","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"a(x omega) = a_0(x) + sum_n=1^N sqrtlambda_n phi_n(x) xi_n(omega)","category":"page"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"where a_0(x) is the mean, lambda_n and phi_n(x) are the eigenvalues and eigenfunctions of the covariance operator, and xi_n are independent standard normal random variables.","category":"page"},{"location":"coefficients/#API","page":"Stochastic Coefficients","title":"API","text":"","category":"section"},{"location":"coefficients/#ExtendableASGFEM.AbstractStochasticCoefficient","page":"Stochastic Coefficients","title":"ExtendableASGFEM.AbstractStochasticCoefficient","text":"abstract type AbstractStochasticCoefficient{T}\n\nA stochastic coefficient is assumed to have the Karhunen-Loeve expansion form\n\na(yx) = a_0(x) + sum_m=1^infty y_m a_m(x) with (centered independent) random variables y_m and basis functions a_m(x) that need to be specified (together with their gradients) and expectation value a_0 (in general they steam from a spectral analysis of the covariance operator of a).\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.expa_PCE_mop-Union{Tuple{ONBType}, Tuple{T}, Tuple{TensorizedBasis{T, ONBType}, AbstractStochasticCoefficient{T}}} where {T, ONBType}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.expa_PCE_mop","text":"expa_PCE_mop(\n    TB::TensorizedBasis{T, ONBType},\n    SC::AbstractStochasticCoefficient{T};\n    N_truncate,\n    factor\n) -> Union{Tuple{ExtendableASGFEM.var\"#closure#48\"{_A, TensorizedBasis{T, ONBType, MIType}, ExtendableASGFEM.var\"#lambda_mu#47\"{T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, Int64} where {_A, T, ONBType, MIType, T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, ExtendableASGFEM.var\"#lambda_mu#47\"{_A, Int64, Int64, SingleStochasticCoefficient{T, k}} where {_A, T, k}}, Tuple{ExtendableASGFEM.var\"#closure#48\"{_A, TensorizedBasis{T, ONBType, MIType}, ExtendableASGFEM.var\"#lambda_mu#47\"{T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, Int64} where {_A, T, ONBType, MIType, T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, ExtendableASGFEM.var\"#lambda_mu#47\"{_A, Int64, Int64, StochasticCoefficientCosinus{T}} where {_A, T}}}\n\n\nprepares two functions\n\nlambda_mu!(result, input, qpinfo)\nexpa!(result, input, qpinfo)\n\nthat calculate λ_μ, which are orthogonal decomposition coefficient functions of exp(a) ≈ ∑ λ_μ H_μ w.r.t. to the multi-indices μ and their associated orthogonal basis functions H_μ in TB, as well as (an approximation based on this decomposition of) exp(a).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_a!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_a!","text":"get_a!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#34\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\na!(result, x, y)\n\nthat evaluates the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_am_x-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_am_x","text":"get_am_x(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#get_am_x##0\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_am_x!(result, input, qpinfo)\n\nthat evaluates a_m(qpinfo.x) input (used to define ExtendableFEM operator kernels).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_expa!-Tuple{AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_expa!","text":"get_expa!(\n    SC::AbstractStochasticCoefficient;\n    factor\n) -> ExtendableASGFEM.var\"#closure#38\"{Int64, ExtendableASGFEM.var\"#closure#34\"{Int64, var\"#s179\", _A}} where {T, var\"#s179\"<:AbstractStochasticCoefficient{T}, _A}\n\n\nprepares a function of interface\n\nget_expa!(result, x, y)\n\nthat evaluates the exponential of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada!","text":"get_grada!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#36\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\nget_grada!(result, x, y)\n\nthat evaluates the spatial gradient of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of same length as x).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada_x_sigma-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}, Any}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada_x_sigma","text":"get_grada_x_sigma(\n    dim,\n    SC::AbstractStochasticCoefficient{T},\n    y\n) -> ExtendableASGFEM.var\"#closure#get_grada_x_sigma##0\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_grada_x_sigma!(result, input, qpinfo)\n\nthat evaluates ∇a(qpinfo.x) ⋅ σ(qpinfo.x) (used to define ExtendableFEM operator kernels and σ is expected to be some vector-valued quantity of same length).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_gradam_x_u-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_gradam_x_u","text":"get_gradam_x_u(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#get_gradam_x_u##0\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_gradam_x_u!(result, input, qpinfo)\n\nthat evaluates ∇a_m(qpinfo.x) u(qpinfo.x) (used to define ExtendableFEM operator kernels and input is expected to be some scalar quantity).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.plot_am-Tuple{ExtendableGrids.ExtendableGrid, Any, AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.plot_am","text":"plot_am(\n    xgrid::ExtendableGrids.ExtendableGrid,\n    m,\n    SC::AbstractStochasticCoefficient;\n    Plotter,\n    kwargs...\n)\n\n\nreturns a scalarplot of the m-th coefficient functiona a_m interpolated on the given grid. The Plotter backend can be changed with the Plotter argument (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"StochasticCoefficientCosinus","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"An example of a particular KLE with cosinus type basis function is given by the following subtype.","category":"page"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"struct StochasticCoefficientCosinus{T} <: AbstractStochasticCoefficient{T}\n\nExpansion of the form\n\na(x,y) = a_0(x) + ∑_m y_m a_m(x)\n\nwhere the a_m are of cosinus type.\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus-Tuple{}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"StochasticCoefficientCosinus(\n;\n    T,\n    τ,\n    start,\n    decay,\n    mean,\n    maxm\n) -> StochasticCoefficientCosinus{Float64}\n\n\nconstructor for StochasticCoefficientCosinus of type T (default = Float64), where decay (default = 2) steers the decay of the coefficient basis functions (the larger the faster), mean (default = 0) is the mean value of the coefficient, maxm (default = 100) is the maximal number of stochastic random variables, and τ (default = 1) is a uniform scaling factors\n\n\n\n\n\n","category":"method"},{"location":"modelproblems/#Model-Problems","page":"Model Problems","title":"Model Problems","text":"","category":"section"},{"location":"modelproblems/","page":"Model Problems","title":"Model Problems","text":"The following model problems are available and are dispatched via the following types.","category":"page"},{"location":"modelproblems/#ExtendableASGFEM.PoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.PoissonProblemPrimal","text":"abstract type PoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with linear stochastic coefficient a that seeks u such that\n\n-mathrmdiv(a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemPrimal","text":"abstract type LogTransformedPoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with exponential stochastic coefficient e^a that seeks u such that\n\n-mathrmdiv(e^a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\nThe stochastic Galerkin FEM solves the equivalent transformed problem\n\n-mathrmdiv(nabla u(yx)) - nabla a(yx) cdot nabla u(yx) = e^-a(yx) f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemDual","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemDual","text":"abstract type LogTransformedPoissonProblemDual <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with exponential stochastic coefficient e^a that seeks u such that\n\n-mathrmdiv(e^a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\nThe dual formulation of the log-transformed formulation of the Poisson problem introduces the auxiliary stress variable p = - e^a(yx) nabla u(yx) = -ũ - aũ for the transformed ũ = e^-a u.\n\nIts weak formulation seeks (pũ) such that\n\nbeginaligned\n(p q) + (ũ nabla a q) - (mathrmdiv(q) ũ)  = 0 quad textfor all  q \n-(mathrmdiv(p) v)  = (f v) quad textfor all  v\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ONBasis","page":"ONBasis","title":"ONBasis","text":"","category":"section"},{"location":"onbasis/","page":"ONBasis","title":"ONBasis","text":"An ONBasis (orthonormal basis) encapsulates information about the orthogonal polynomials associated with a given probability distribution. This includes norms, quadrature rules, and cached evaluations at quadrature points. The ONBasis serves as a fundamental building block for constructing the tensorized basis linked to the multi-indices in the stochastic discretization.","category":"page"},{"location":"onbasis/#ExtendableASGFEM.ONBasis","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"ONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder;\n    ...\n) -> ONBasis{Float64}\nONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder,\n    maxquadorder;\n    T\n) -> ONBasis{Float64}\n\n\nConstructs an ONBasis for the given orthogonal polynomial type and associated weight function, up to the specified maximum polynomial order.\n\nArguments\n\nOBT: The type of orthogonal polynomial (subtype of OrthogonalPolynomialType).\nmaxorder: The highest polynomial degree to include in the basis.\nmaxquadorder: The quadrature order to use for integration (default: 2 * maxorder).\nT: The floating-point type for computations (default: Float64).\n\nReturns\n\nAn ONBasis object containing:\n\nThe norms of all basis functions.\nA workspace for storing evaluations.\nThe quadrature rule (points and weights).\nPrecomputed values of all basis functions at the quadrature points.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.ONBasis-2","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"struct ONBasis{T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\nA structure that stores all relevant information for an orthonormal polynomial basis (ONBasis), including:\n\nThe norms of all basis functions.\nThe quadrature rule (points and weights) used for integration.\nPrecomputed values of all basis functions at the quadrature points.\nA workspace for storing the result of the last evaluation.\n\nThis structure enables efficient evaluation, integration, and manipulation of orthogonal polynomial bases for stochastic Galerkin methods and related applications.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.OrthogonalPolynomialType-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.OrthogonalPolynomialType","text":"OrthogonalPolynomialType(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the OrthogonalPolynomialType\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.distribution-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.distribution","text":"distribution(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the distribution associated to the orthogonal polynomials\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.evaluate-Union{Tuple{maxorder}, Tuple{OBT}, Tuple{T}, Tuple{ONBasis{T, OBT, maxorder}, Any}} where {T, OBT, maxorder}","page":"ONBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    ONB::ONBasis{T, OBT, maxorder},\n    x;\n    normalize\n) -> Vector\n\n\nEvaluates all basis polynomials at point x\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.integral-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.integral","text":"integral(ONB::ONBasis, j; normalize) -> Any\n\n\nEvaluates the integral of a single basis function.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.norm4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.norm4poly","text":"norm4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the norm of the p-th polynomial\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qp-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qp","text":"qp(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qw-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qw","text":"qw(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature weights\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.scalar_product-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.scalar_product","text":"scalar_product(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the scalar product of two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product-Tuple{ONBasis, Any, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product","text":"triple_product(ONB::ONBasis, j, k, l; normalize) -> Any\n\n\nEvaluates the triple product of three basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product_y-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product_y","text":"triple_product_y(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the triple product of two basis functions and y.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4poly","text":"vals4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the values of the p-th polynomial at all quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4qp-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4qp","text":"vals4qp(ONB::ONBasis, k) -> Any\n\n\nreturns the values of all polynomials at the k-th quadrature point\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4xref-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.vals4xref","text":"vals4xref(\n    ONB::ONBasis\n) -> StaticArraysCore.SMatrix{nquad, npoly, T} where {T<:Real, npoly, nquad}\n\n\nreturns the values of all polynomials at the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"#ExtendableASGFEM","page":"Home","title":"ExtendableASGFEM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an implementation of the stochastic Galerkin finite element method (SGFEM) for selected two-dimensional model problems involving Karhunen-Loève expansions (KLE) of stochastic coefficients. The resulting large-scale systems exhibit a tensorized structure and are efficiently solved using iterative solvers. Adaptive a posteriori error estimators guide both spatial and stochastic refinement to ensure accuracy and efficiency.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Spatial discretization is performed using the finite element packages ExtendableFEM.jl and ExtendableFEMBase.jl.","category":"page"},{"location":"#Example-Script","page":"Home","title":"Example Script","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A script for running adaptive SGFEM experiments is provided in scripts/poisson.jl. It supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Poisson problem with linear coefficient\nLog-transformed Poisson problem with exponential coefficient\nDual formulation of the log-transformed problem (WIP)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The script handles both spatial and stochastic adaptivity, and includes tools for result visualization and error analysis. For a detailed description of all available parameters and usage instructions, see Script Documentation.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"Adaptive stochastic Galerkin FEM\"         M. Eigel, C.J. Gittelson, C. Schwab, E. Zander         CMAME 270, 1 (2014), 247–269         Journal-Link         Preprint-Link\n[2]   \"A posteriori error control for stochastic Galerkin FEM with high-dimensional random parametric PDEs\"         M. Eigel, C. Merdon         To appear in: Error Control, Adaptive Discretizations, and Applications, Part 3, Academic Press         Preprint-Link\n[3]   \"Local equilibration error estimators for guaranteed error control in adaptive higher-order stochastic Galerkin finite element methods\"         M. Eigel and C. Merdon         SIAM/ASA J. Uncertainty Quantification 4(1) (2016), 1372–1397         Journal-Link         Preprint-Link","category":"page"}]
}
