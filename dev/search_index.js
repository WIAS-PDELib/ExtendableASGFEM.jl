var documenterSearchIndex = {"docs":
[{"location":"modelproblems/#Model-Problems","page":"Model Problems","title":"Model Problems","text":"","category":"section"},{"location":"modelproblems/","page":"Model Problems","title":"Model Problems","text":"The following model problems are available and are dispatched via the following types.","category":"page"},{"location":"modelproblems/#ExtendableASGFEM.PoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.PoissonProblemPrimal","text":"abstract type PoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with linear stochastic coefficient a that seeks u such that\n\n-mathrmdiv(a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemPrimal","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemPrimal","text":"abstract type LogTransformedPoissonProblemPrimal <: ExtendableASGFEM.AbstractModelProblem\n\nPoisson problem with exponential stochastic coefficient e^a that seeks u such that\n\n-mathrmdiv(e^a(yx) nabla u(yx)) = f(x) quad textfor  (yx) in Gamma times D\n\nThe stochastic Galerkin FEM solves the equivalent transformed problem\n\n-mathrmdiv(nabla u(yx)) - nabla a(yx) cdot nabla u(yx) = e^-a(yx) f(x) quad textfor  (yx) in Gamma times D\n\n\n\n\n\n","category":"type"},{"location":"modelproblems/#ExtendableASGFEM.LogTransformedPoissonProblemDual","page":"Model Problems","title":"ExtendableASGFEM.LogTransformedPoissonProblemDual","text":"abstract type LogTransformedPoissonProblemDual <: ExtendableASGFEM.AbstractModelProblem\n\nDual log-transformed formulation of the Poisson problem with exponential stochastic coefficient (WIP).\n\n\n\n\n\n","category":"type"},{"location":"plots/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plots/","page":"Plotting","title":"Plotting","text":"The following special plot functions are available and basically delegate to the plotting routines from ExtendableFEM/GridVisualize.","category":"page"},{"location":"plots/#ExtendableASGFEM.plot_basis-Union{Tuple{ONBasis{T, OBT, npoly, nquad}}, Tuple{nquad}, Tuple{npoly}, Tuple{OBT}, Tuple{T}} where {T, OBT, npoly, nquad}","page":"Plotting","title":"ExtendableASGFEM.plot_basis","text":"plot_basis(\n    ONB::ONBasis{T, OBT, npoly, nquad};\n    Plotter,\n    resolution,\n    kwargs...\n)\n\n\nplots the basis functions of the ONBasis ONB via GridVisualize. The Plotter argument determines the backend (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"plots/#ExtendableASGFEM.plot_modes-Tuple{SGFEVector}","page":"Plotting","title":"ExtendableASGFEM.plot_modes","text":"plot_modes(\n    sol::SGFEVector;\n    unknown,\n    Plotter,\n    nmodes,\n    ncols,\n    width,\n    sort\n) -> GridVisualize.GridVisualizer\n\n\nplots scalarplots of the stochastic modes of sol sorted by their norm via ExtendableFEM.plots/GridVisualize. The Plotter argument determines the backend (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"Solving requires a spatial and stochastic discretization. Both are connected in a special vector structure that is passed to a solve function that runs a special iterative solver for each model problem.","category":"page"},{"location":"solvers/#SGFEVector","page":"Solver","title":"SGFEVector","text":"","category":"section"},{"location":"solvers/","page":"Solver","title":"Solver","text":"The spatial discretization is represented by s single finite element space from ExtendableFEM.jl, while the stochastic discretization is represented by a tensorized basis for the parameter space of the stochastic coefficient. Both have to be prepared in advance.","category":"page"},{"location":"solvers/","page":"Solver","title":"Solver","text":"note: Note\nCurrently it is not possible to use different finite element spaces for different multi-indices, but this feature might be added in the future.","category":"page"},{"location":"solvers/#ExtendableASGFEM.SGFEVector","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"struct SGFEVector{T, Tv, Ti, ONBType<:ONBasis, MIType}\n\nstructure that builds upon ExtendableFEMBase.FEVector and adds information on the stochastic discretization, i.e. the used TensoriedBasis\n\n\n\n\n\n","category":"type"},{"location":"solvers/#ExtendableASGFEM.SGFEVector-Union{Tuple{MIType}, Tuple{ONBType}, Tuple{Ti}, Tuple{Tv}, Tuple{Vector{<:ExtendableFEMBase.FESpace{Tv, Ti}}, TensorizedBasis{Tv, ONBType, MIType}}} where {Tv, Ti, ONBType, MIType}","page":"Solver","title":"ExtendableASGFEM.SGFEVector","text":"SGFEVector(\n    FES::Array{<:ExtendableFEMBase.FESpace{Tv, Ti}, 1},\n    TB::TensorizedBasis{Tv, ONBType, MIType};\n    active_modes,\n    T,\n    unames\n) -> SGFEVector\n\n\nconstructs an SGFEVector for the given (spatial) finite element space FES and the (tensorized basis of the stochastic discretization) TB. \n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    u::Int64,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the FEVectorBlock for the i-th stochastic mode of the u-th unknown\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.getindex-Tuple{SGFEVector, Int64}","page":"Solver","title":"Base.getindex","text":"getindex(\n    SGFEV::SGFEVector,\n    i::Int64\n) -> ExtendableFEMBase.FEVectorBlock\n\n\nreturns the i-th stochastic mode\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.length-Tuple{SGFEVector}","page":"Solver","title":"Base.length","text":"length(SGFEV::SGFEVector) -> Int64\n\n\nreturns the length of the full vector, i.e., the total number of degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.show-Tuple{IO, SGFEVector}","page":"Solver","title":"Base.show","text":"show(io::IO, SGFEV::SGFEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Base.size-Tuple{SGFEVector}","page":"Solver","title":"Base.size","text":"size(SGFEV::SGFEVector)\n\n\nreturns a tuple with the number of active stochastic modes and the number of spatial degrees of freedom\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.fetypes-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.fetypes","text":"fetypes(SGFEV::SGFEVector) -> Vector\n\n\nreturns the finite element types of the (spatial) FE spaces\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.num_multiindices-Tuple{SGFEVector}","page":"Solver","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(SGFEV::SGFEVector) -> Int64\n\n\nreturns the number of active modes (that are used from the stored tensorized basis)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#ExtendableASGFEM.set_sample!-Tuple{SGFEVector, AbstractVector}","page":"Solver","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(SGFEV::SGFEVector, S::AbstractVector)\n\n\nevaluates the SGVector at that sample and stores the results in SGFEV.FEV.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Solve-function","page":"Solver","title":"Solve function","text":"","category":"section"},{"location":"solvers/#ExtendableASGFEM.solve!-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Solver","title":"ExtendableASGFEM.solve!","text":"solve!(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    rhs,\n    use_iterative_solver,\n    bonus_quadorder_f,\n    bonus_quadorder_a,\n    kwargs...\n)\n\n\nsolves the specified model problem with the given stochastic coefficient C and right-hand side rhs and writes the solution into sol. Via this sol vector the spatial and stochastic discretization is communicated as well as initial data for the iterative solver. The boolean use_iterative_solver (default is true) determines if the iterative solver is used or if the full matrix is assembled and solved by a direct solver (very slow for larger systems). The parameters bonus_quadorder_f (default is 0) and bonus_quadorder_a (default is 2) can be used to increase the quadrature order in terms that involve the rhs or the stochastic coefficient, respectively.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#TensorizedBasis","page":"TensorizedBasis","title":"TensorizedBasis","text":"","category":"section"},{"location":"tonbasis/","page":"TensorizedBasis","title":"TensorizedBasis","text":"Each multi-index mu = mu_1mu_2ldotsmu_M encodes a tensorized basis function for the parameter space of the form H_mu = prod_k=1^M H_k where the H_k are the orthogonal polynomials. The TensorizedBasis collects all information necessary to evaluate those basis functions, i.e. the set of multi-indices and the triple products of the form (y_mH_mu H_lambda) for each m and mu lambda in the set of multi-indices as a sparse matrix. There are analytic formulas to evaluate these triple products in terms of recurrence coefficients, but it makes sense to store them for faster evaluation times.","category":"page"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"TensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder;\n    ...\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\nTensorizedBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    M,\n    order,\n    maxorder,\n    maxquadorder;\n    T,\n    multi_indices\n) -> TensorizedBasis{Float64, ONBasis{T, OBT, npoly, nquad}} where {T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\n\nconstructor for a tensorized basis for the given OrthogonalPolynomialType. If no multi-indices are provided it automatically generates all multi-indices up to support length M and polynomial order maxorder.\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#ExtendableASGFEM.TensorizedBasis-2","page":"TensorizedBasis","title":"ExtendableASGFEM.TensorizedBasis","text":"struct TensorizedBasis{T<:Real, ONBType<:ONBasis, MIType}\n\nStructure that stores information of a tensorized orthogonal for a certain set of multi-indices.\n\n\n\n\n\n","category":"type"},{"location":"tonbasis/#Base.show-Tuple{IO, TensorizedBasis}","page":"TensorizedBasis","title":"Base.show","text":"show(io::IO, TB::TensorizedBasis)\n\n\nshows information on the tensorized basis.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.distribution-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.distribution","text":"distribution(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns distribution associated to the orthogonal basis\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(TB::TensorizedBasis{T}, j) -> Any\n\n\nevaluates the basis function for the j-th multi-index at the sample that was set with set_sample.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_coupling_coefficient-Union{Tuple{T}, Tuple{TensorizedBasis{T}, Any, Any, Any}} where T","page":"TensorizedBasis","title":"ExtendableASGFEM.get_coupling_coefficient","text":"get_coupling_coefficient(\n    TB::TensorizedBasis{T},\n    m,\n    j,\n    k\n) -> Any\n\n\nreturns the triple products between y_m and H_j and H_k for two multi-indices j and k.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.get_multiindex-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.get_multiindex","text":"get_multiindex(TB::TensorizedBasis, j) -> Any\n\n\nreturns the j-th multi-index.\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.maxlength_multiindices-Union{Tuple{TensorizedBasis{T, ONBT}}, Tuple{ONBT}, Tuple{T}} where {T, ONBT}","page":"TensorizedBasis","title":"ExtendableASGFEM.maxlength_multiindices","text":"maxlength_multiindices(TB::TensorizedBasis{T, ONBT}) -> Any\n\n\nreturns the maximal length of the stored multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.num_multiindices-Tuple{TensorizedBasis}","page":"TensorizedBasis","title":"ExtendableASGFEM.num_multiindices","text":"num_multiindices(TB::TensorizedBasis) -> Int64\n\n\nreturns the number of multi-indices\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.sample_distribution-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.sample_distribution","text":"sample_distribution(\n    TB::TensorizedBasis,\n    nsamples;\n    M,\n    Mweights\n) -> Tuple{Matrix{Float64}, Any}\n\n\nGenerate samples and weights for the distribution of the ON basis that the tensorized basis is based upon (that can be used for a Monte-Carlo estimator).\n\n\n\n\n\n","category":"method"},{"location":"tonbasis/#ExtendableASGFEM.set_sample!-Tuple{TensorizedBasis, Any}","page":"TensorizedBasis","title":"ExtendableASGFEM.set_sample!","text":"set_sample!(\n    TB::TensorizedBasis,\n    x;\n    normalize\n) -> Array{Vector{T}, 1} where T<:Real\n\n\nevaluates all basis functions at sample vector x; call this before using evaluate!\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#Stochastic-Coefficients","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"Coefficients are assumed to be represented by a Karhunen-Loeve expansion (KLE) that have the following general structure and API.","category":"page"},{"location":"coefficients/#API","page":"Stochastic Coefficients","title":"API","text":"","category":"section"},{"location":"coefficients/#ExtendableASGFEM.AbstractStochasticCoefficient","page":"Stochastic Coefficients","title":"ExtendableASGFEM.AbstractStochasticCoefficient","text":"abstract type AbstractStochasticCoefficient{T}\n\nA stochastic coefficient is assumed to have the Karhunen-Loeve expansion form\n\na(yx) = a_0(x) + sum_m=1^infty y_m a_m(x) with (centered independent) random variables y_m and basis functions a_m(x) that need to be specified (together with their gradients) and expectation value a_0 (in general they steam from a spectral analysis of the covariance operator of a).\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.expa_PCE_mop-Union{Tuple{ONBType}, Tuple{T}, Tuple{TensorizedBasis{T, ONBType}, AbstractStochasticCoefficient{T}}} where {T, ONBType}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.expa_PCE_mop","text":"expa_PCE_mop(\n    TB::TensorizedBasis{T, ONBType},\n    SC::AbstractStochasticCoefficient{T};\n    N_truncate,\n    factor\n) -> Tuple{ExtendableASGFEM.var\"#closure#52\"{_A, TensorizedBasis{T, ONBType, MIType}, ExtendableASGFEM.var\"#lambda_mu#51\"{T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, Int64} where {_A, T, ONBType, MIType, T1, N_truncate, factor, SC, mu_fac_storage, multi_indices, eval_amu_storage, eval_am}, ExtendableASGFEM.var\"#lambda_mu#51\"{_A, Int64, Int64, <:AbstractStochasticCoefficient{T}} where {_A, T}}\n\n\nprepares two functions\n\nlambda_mu!(result, input, qpinfo)\nexpa!(result, input, qpinfo)\n\nthat calculate λ_μ, which are orthogonal decomposition coefficient functions of exp(a) ≈ ∑ λ_μ H_μ w.r.t. to the multi-indices μ and their associated orthogonal basis functions H_μ in TB, as well as (an approximation based on this decomposition of) exp(a).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_a!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_a!","text":"get_a!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#36\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\na!(result, x, y)\n\nthat evaluates the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_am_x-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_am_x","text":"get_am_x(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#45\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_am_x!(result, input, qpinfo)\n\nthat evaluates a_m(qpinfo.x) input (used to define ExtendableFEM operator kernels).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_expa!-Tuple{AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_expa!","text":"get_expa!(\n    SC::AbstractStochasticCoefficient;\n    factor\n) -> ExtendableASGFEM.var\"#closure#40\"{Int64, ExtendableASGFEM.var\"#closure#36\"{Int64, var\"#s182\", _A}} where {T, var\"#s182\"<:AbstractStochasticCoefficient{T}, _A}\n\n\nprepares a function of interface\n\nget_expa!(result, x, y)\n\nthat evaluates the exponential of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of length 1).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada!-Union{Tuple{AbstractStochasticCoefficient{T}}, Tuple{T}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada!","text":"get_grada!(\n    SC::AbstractStochasticCoefficient{T};\n    factor\n) -> ExtendableASGFEM.var\"#closure#38\"{Int64, <:AbstractStochasticCoefficient{T}} where T\n\n\nprepares a function of interface\n\nget_grada!(result, x, y)\n\nthat evaluates the spatial gradient of the coefficient (times a factor) at space coordinates x and random variables y into result (a vector of same length as x).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_grada_x_sigma-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}, Any}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_grada_x_sigma","text":"get_grada_x_sigma(\n    dim,\n    SC::AbstractStochasticCoefficient{T},\n    y\n) -> ExtendableASGFEM.var\"#closure#47\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_grada_x_sigma!(result, input, qpinfo)\n\nthat evaluates ∇a(qpinfo.x) ⋅ σ(qpinfo.x) (used to define ExtendableFEM operator kernels and σ is expected to be some vector-valued quantity of same length).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.get_gradam_x_u-Union{Tuple{T}, Tuple{Any, AbstractStochasticCoefficient{T}}} where T","page":"Stochastic Coefficients","title":"ExtendableASGFEM.get_gradam_x_u","text":"get_gradam_x_u(\n    m,\n    SC::AbstractStochasticCoefficient{T}\n) -> ExtendableASGFEM.var\"#closure#44\"{_A, <:AbstractStochasticCoefficient{T}} where {_A, T}\n\n\nprepares a function of interface\n\nget_gradam_x_u!(result, input, qpinfo)\n\nthat evaluates ∇a_m(qpinfo.x) u(qpinfo.x) (used to define ExtendableFEM operator kernels and input is expected to be some scalar quantity).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#ExtendableASGFEM.plot_am-Tuple{ExtendableGrids.ExtendableGrid, Any, AbstractStochasticCoefficient}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.plot_am","text":"plot_am(\n    xgrid::ExtendableGrids.ExtendableGrid,\n    m,\n    SC::AbstractStochasticCoefficient;\n    Plotter,\n    kwargs...\n) -> Any\n\n\nreturns a scalarplot of the m-th coefficient functiona a_m interpolated on the given grid. The Plotter backend can be changed with the Plotter argument (e.g. GLMakie, CairoMakie, PyPlot, Plots).\n\n\n\n\n\n","category":"method"},{"location":"coefficients/#StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"StochasticCoefficientCosinus","text":"","category":"section"},{"location":"coefficients/","page":"Stochastic Coefficients","title":"Stochastic Coefficients","text":"An example of a particular KLE with cosinus type basis function is given by the following subtype.","category":"page"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"struct StochasticCoefficientCosinus{T} <: AbstractStochasticCoefficient{T}\n\nExpansion of the form\n\na(x,y) = a_0(x) + ∑_m y_m a_m(x)\n\nwhere the a_m are of cosinus type.\n\n\n\n\n\n","category":"type"},{"location":"coefficients/#ExtendableASGFEM.StochasticCoefficientCosinus-Tuple{}","page":"Stochastic Coefficients","title":"ExtendableASGFEM.StochasticCoefficientCosinus","text":"StochasticCoefficientCosinus(\n;\n    T,\n    τ,\n    start,\n    decay,\n    mean,\n    maxm\n) -> StochasticCoefficientCosinus{Float64}\n\n\nconstructor for StochasticCoefficientCosinus of type T (default = Float64), where decay (default = 2) steers the decay of the coefficient basis functions (the larger the faster), mean (default = 0) is the mean value of the coefficient, maxm (default = 100) is the maximal number of stochastic random variables, and τ (default = 1) is a uniform scaling factors\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ONBasis","page":"ONBasis","title":"ONBasis","text":"","category":"section"},{"location":"onbasis/","page":"ONBasis","title":"ONBasis","text":"An ONBasis (=orthonormal basis) stores information for the orthogonal polynomials of the disctribution, like norms, quadrature rules and cached evaluations at quadrature points. It is the main building brick for the tensorized basis associated to the multi-indices of the stochastic discretization.","category":"page"},{"location":"onbasis/#ExtendableASGFEM.ONBasis","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"ONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder;\n    ...\n) -> ONBasis{Float64}\nONBasis(\n    OBT::Type{<:OrthogonalPolynomialType},\n    maxorder,\n    maxquadorder;\n    T\n) -> ONBasis{Float64}\n\n\nConstructs an ONBasis for the given OrthogonalPolynomialType (and the associated weight function) and the maximal polynomial order.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.ONBasis-2","page":"ONBasis","title":"ExtendableASGFEM.ONBasis","text":"struct ONBasis{T<:Real, OBT<:OrthogonalPolynomialType, npoly, nquad}\n\nStructure that stores information of an orthogonal basis, i.e., their norms, quadrature rules and values at reference points, and the result of the last evaluate call.\n\n\n\n\n\n","category":"type"},{"location":"onbasis/#ExtendableASGFEM.OrthogonalPolynomialType-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.OrthogonalPolynomialType","text":"OrthogonalPolynomialType(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the OrthogonalPolynomialType\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.distribution-Union{Tuple{ONBasis{T, OBT}}, Tuple{OBT}, Tuple{T}} where {T, OBT}","page":"ONBasis","title":"ExtendableASGFEM.distribution","text":"distribution(ONB::ONBasis{T, OBT}) -> Any\n\n\nreturns the distribution associated to the orthogonal polynomials\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.evaluate-Union{Tuple{maxorder}, Tuple{OBT}, Tuple{T}, Tuple{ONBasis{T, OBT, maxorder}, Any}} where {T, OBT, maxorder}","page":"ONBasis","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    ONB::ONBasis{T, OBT, maxorder},\n    x;\n    normalize\n) -> Vector\n\n\nEvaluates all basis polynomials at point x\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.integral-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.integral","text":"integral(ONB::ONBasis, j; normalize) -> Any\n\n\nEvaluates the integral of a single basis function.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.norm4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.norm4poly","text":"norm4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the norm of the p-th polynomial\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qp-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qp","text":"qp(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.qw-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.qw","text":"qw(\n    ONB::ONBasis\n) -> StaticArraysCore.SVector{nquad, T} where {T<:Real, nquad}\n\n\nreturns the quadrature weights\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.scalar_product-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.scalar_product","text":"scalar_product(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the scalar product of two basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product-Tuple{ONBasis, Any, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product","text":"triple_product(ONB::ONBasis, j, k, l; normalize) -> Any\n\n\nEvaluates the triple product of three basis functions.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.triple_product_y-Tuple{ONBasis, Any, Any}","page":"ONBasis","title":"ExtendableASGFEM.triple_product_y","text":"triple_product_y(ONB::ONBasis, j, k; normalize) -> Any\n\n\nEvaluates the triple product of two basis functions and y.\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4poly-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4poly","text":"vals4poly(ONB::ONBasis, p) -> Any\n\n\nreturns the values of the p-th polynomial at all quadrature points\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4qp-Tuple{ONBasis, Any}","page":"ONBasis","title":"ExtendableASGFEM.vals4qp","text":"vals4qp(ONB::ONBasis, k) -> Any\n\n\nreturns the values of all polynomials at the k-th quadrature point\n\n\n\n\n\n","category":"method"},{"location":"onbasis/#ExtendableASGFEM.vals4xref-Tuple{ONBasis}","page":"ONBasis","title":"ExtendableASGFEM.vals4xref","text":"vals4xref(\n    ONB::ONBasis\n) -> StaticArraysCore.SMatrix{nquad, npoly, T} where {T<:Real, npoly, nquad}\n\n\nreturns the values of all polynomials at the quadrature points\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Adaptivity-and-error-control","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"","category":"section"},{"location":"estimators/#Residual-based-a-posteriori-error-estimation","page":"Adaptivity and error control","title":"Residual-based a posteriori error estimation","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Spatial error estimation refers to classical residual-based error estimation for the zero-th multi index that refers to the mean value. Stochastic error control has to estimate which stochastic mode needs to be refined in the sense that either the polynomial degree is increased or neighbouring stochastic modes are activated. Both is represented by the multi-indices. Then unified error control allows to perform residual-based error estimation for the subresiduals that are associated to each multi-index and depend on the model problem (see references on the main page for details).","category":"page"},{"location":"estimators/#ExtendableASGFEM.estimate-Tuple{Type{ExtendableASGFEM.AbstractModelProblem}, SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.estimate","text":"estimate(\n    ::Type{ExtendableASGFEM.AbstractModelProblem},\n    sol::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    kwargs...\n) -> Tuple{DataType, DataType, Vector{Vector{Int64}}}\n\n\ncomputes the residual-based a posteriori error estimator for the current solution vector sol for the given model problem and stochastic coefficient C and returns:\n\neta4modes = array with total error estimators for each multi-index (corresponding to the enriched set of multi-indices with the current active modes coming first)\neta4cell = array with total error estimators for each cell in grid (for spatial refinement)\nmulti_indices_extended = enriched set of multi-indices used for the computations\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Multi-index-management","page":"Adaptivity and error control","title":"Multi index management","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"Depending on the model problem and stochastic coefficient the amount of multi indices that should be added to the error estimation varies. Here are some methods that help with enriching the set of multi-indices.","category":"page"},{"location":"estimators/#ExtendableASGFEM.add_boundary_modes-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.add_boundary_modes","text":"add_boundary_modes(\n    multi_indices;\n    p_extension,\n    tail_extension\n) -> Any\n\n\nadds new stochastic modes:\n\nfor each existing mode all neighbouring modes are added (= all possible copies of that mode where one dimension is increased by 1)\np_extension additionally ensures that the polynomial degree of the first dimension is increased by this amount\ntail_extension activates tail_expansion[1] many new stochastic modes with order 1,  for each existing mode also the next tail_expansion[2] many higher stochastic modes are activated or increased\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.classify_modes","page":"Adaptivity and error control","title":"ExtendableASGFEM.classify_modes","text":"classify_modes(multi_indices) -> NTuple{5, Vector{Int64}}\nclassify_modes(\n    multi_indices,\n    active_modes\n) -> NTuple{5, Vector{Int64}}\n\n\nclassifies all multi indices into these categories:\n\nactive_int = mode and all its direct neighbours (+1 in all active and the next dimensions) are in active_modes\nactive_bnd = mode but not all its direct neighbours are in active_modes\ninactive_bnd = inactive mode that has an active neighbour\ninactive_bnd2 = inactive mode that has an neighbour in inactive_bnd \ninactive_else = all other\n\n\n\n\n\n","category":"function"},{"location":"estimators/#ExtendableASGFEM.generate_multiindices-Tuple{Any, Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.generate_multiindices","text":"generate_multiindices(M, deg) -> Any\n\n\ngenerates multi-indices for M dimensions up to degree deg\n\n\n\n\n\n","category":"method"},{"location":"estimators/#ExtendableASGFEM.prepare_multi_indices!-Tuple{Any}","page":"Adaptivity and error control","title":"ExtendableASGFEM.prepare_multi_indices!","text":"prepare_multi_indices!(multi_indices; minimal_length)\n\n\nensures that all multi-indices have the same length\n\n\n\n\n\n","category":"method"},{"location":"estimators/#Monte-carlo-sampling-estimator","page":"Adaptivity and error control","title":"Monte carlo sampling estimator","text":"","category":"section"},{"location":"estimators/","page":"Adaptivity and error control","title":"Adaptivity and error control","text":"There is also a hierarchical Monte carlo error estimator available that compares the solution with a higher order discrete solution for sampled deterministic problems. This is merely intended as a way to compute the reference error to assess the efficiency of the residual-based error estimator.","category":"page"},{"location":"estimators/#ExtendableASGFEM.calculate_sampling_error-Tuple{SGFEVector, AbstractStochasticCoefficient}","page":"Adaptivity and error control","title":"ExtendableASGFEM.calculate_sampling_error","text":"calculate_sampling_error(\n    SolutionSGFEM::SGFEVector,\n    C::AbstractStochasticCoefficient;\n    problem,\n    bonus_quadorder_a,\n    bonus_quadorder_f,\n    order,\n    rhs,\n    dim,\n    Msamples,\n    parallel_sampling,\n    dimensionwise_error,\n    energy_norm,\n    debug,\n    nsamples\n) -> NTuple{4, Vector{Float64}}\n\n\nestimates the error for the model problem problem by Monte carlo sampling: for each sample a discrete finite element solution of the deterministic model problem with fixed (sampled) coefficient with polynomial order order is computed and compared to the given stochastic Galerkin solution SolutionSGFEM. Return values (each arrays of length M+1 where M is the length of the multi-indices) are:\n\ntotalerrorL2stress_weighted : mean L2 error of the stress with samples weighted by the distribution\ntotalerrorL2u_weighted : mean L2 error with samples weighted by the distribution\ntotalerrorL2stress_uniform : mean L2 error of the stress with samples weighted uniformly\ntotalerrorL2u_uniform : mean L2 error with samples weighted uniformly\n\nThe m-th component of these arrays are the errors when only multi-indices of up to order m are included.\n\n\n\n\n\n","category":"method"},{"location":"#ExtendableASGFEM","page":"Home","title":"ExtendableASGFEM","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements the stochastic Galerkin finite element method for certain two dimensional model problems involving KLE of stochastic coefficients. The rather huge systems have a tensorized structure and are solved by iterative solvers. A posteriori error estimators steer the spatial and stochastic refinement.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The spatial discretization is based on the finite element package ExtendableFEM.jl/ExtendableFEMBase.jl","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"Adaptive stochastic Galerkin FEM\"\n      M. Eigel, C.J. Gittelson, C. Schwab, E. Zander\n      CMAME 270, 1 (2014), 247–269\n      >Journal-Link<       >Preprint-Link<\n[2]   \"A posteriori error control for stochastic Galerkin FEM with high-dimensional random parametric PDEs\",\n      M. Eigel, C. Merdon\n      to be published in: Error Control, Adaptive Discretizations, and Applications, Part 3, Academic Press\n      >Preprint-Link<\n[3]   \"Local equilibration error estimators for guaranteed error control in adaptive higher-order stochastic  Galerkin finite element methods\"\n      M. Eigel and C. Merdon\n      SIAM/ASA J. Uncertainty Quantification 4(1) (2016), 1372–1397\"\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"orthogonal_polynomials/#Orthogonal-Polynomials","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"The stochastic discretization of random variables involves global polynomials that are orthogonal with respect to the involved random distribution of the y_m. These polynomials can be generated by some recurrence relation with coefficients that depend on the distribution.","category":"page"},{"location":"orthogonal_polynomials/#Recurrence-relations","page":"Orthogonal Polynomials","title":"Recurrence relations","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"Orthogonal polynomials H_n with respect to some weight function omega, i.e.,","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"int_Gamma omega(y) H_n(y) H_m(y) dy = N^2_nmdelta_nm","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"where ","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"  N_nn =  H_n _omega^2 = int_Gamma omega(y) H_n(y) H_n(y) dy","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"satisfy the three-term recurrence relation","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\n  H_n+2(y)  = (a_n y-b_n) H_n+1(y) - c_n H_n(y)\n  endaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"initialized by H_0  = 0 and H_1 = 1.","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate!-Tuple{Any, Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate!","text":"evaluate!(\n    y,\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n)\n\n\nEvaluates the first n+1 orthogonal polynomials at a single x and write result into y\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Tuple{Type{<:OrthogonalPolynomialType}, Integer, Real}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::Real\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials at a single x\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.evaluate-Union{Tuple{T}, Tuple{Type{<:OrthogonalPolynomialType}, Integer, AbstractVector{T}}} where T","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.evaluate","text":"evaluate(\n    basis::Type{<:OrthogonalPolynomialType},\n    n::Integer,\n    x::AbstractArray{T, 1}\n) -> Any\n\n\nEvaluates the first n+1 orthogonal polynomials at a vector of x\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.normalise_recurrence_coefficients-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.normalise_recurrence_coefficients","text":"normalise_recurrence_coefficients(\n    OBT::Type{<:OrthogonalPolynomialType},\n    k\n) -> Tuple{Any, Any, Any}\n\n\nChanges the recurrence coefficients, such that basis functions are normalized.\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#LinearAlgebra.norm-Tuple{Type{<:OrthogonalPolynomialType}, Any}","page":"Orthogonal Polynomials","title":"LinearAlgebra.norm","text":"norm(basis::Type{<:OrthogonalPolynomialType}, n; gr) -> Any\n\n\ncomputes the norms of the first n+1 polynomials by Gauss quadrature\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Legendre-Polynomials-(uniform-distribution)","page":"Orthogonal Polynomials","title":"Legendre Polynomials (uniform distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = 12 in the interval -11 (uniform distribution), take a_n = (2n+1)(n+1), b_n = 0 and c_n = n(n+1). The norms of the resulting Legendre polynomials are given by","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = frac22n+1","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.LegendrePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.LegendrePolynomials","text":"abstract type LegendrePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Legendre Polynomials\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{LegendrePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{LegendrePolynomials}\n) -> Distributions.Uniform{Float64}\n\n\nReturns the distribution associated to the Legendre polynomial\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{LegendrePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{LegendrePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Legendre polynomial\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{LegendrePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{LegendrePolynomials},\n    k::Integer\n) -> Tuple{Int64, Any, Any}\n\n\nReturns the recurrence coefficients for the k-th Legendre polynomial\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#Hermite-Polynomials-(normal-distribution)","page":"Orthogonal Polynomials","title":"Hermite Polynomials (normal distribution)","text":"","category":"section"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"For the weight function omega(y) = exp(-y^22)(2pi) (normal distribution), take a_n = 1, b_n = 0 and c_n = n. Then, the first six polynomials read","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"beginaligned\nH_0  = 0\nH_1  = 1\nH_2  = y\nH_3  = y^2 - 1\nH_4  = y^3 - 3y\nH_5  = y^4 - 6y^2 +3\nendaligned","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"and their norms are given by","category":"page"},{"location":"orthogonal_polynomials/","page":"Orthogonal Polynomials","title":"Orthogonal Polynomials","text":"     H_n ^2_omega = n","category":"page"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.HermitePolynomials","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.HermitePolynomials","text":"abstract type HermitePolynomials <: OrthogonalPolynomialType\n\nType for dispatching Hermite Polynomials\n\n\n\n\n\n","category":"type"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.distribution-Tuple{Type{HermitePolynomials}}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.distribution","text":"distribution(\n    _::Type{HermitePolynomials}\n) -> Distributions.Normal{Float64}\n\n\nReturns the distribution associated to the Hermite polynomial\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.norms-Tuple{Type{HermitePolynomials}, Any}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.norms","text":"norms(_::Type{HermitePolynomials}, k) -> Any\n\n\nReturns the norm of the k-th Hermite polynomial\n\n\n\n\n\n","category":"method"},{"location":"orthogonal_polynomials/#ExtendableASGFEM.recurrence_coefficients-Tuple{Type{HermitePolynomials}, Integer}","page":"Orthogonal Polynomials","title":"ExtendableASGFEM.recurrence_coefficients","text":"recurrence_coefficients(\n    _::Type{HermitePolynomials},\n    k::Integer\n) -> Tuple{Int64, Int64, Integer}\n\n\nReturns the recurrence coefficients for the k-th Legendre polynomial\n\n\n\n\n\n","category":"method"}]
}
